{"count":20,"start":0,"total":87,"books":[{"rating":{"max":10,"numRaters":2014,"average":"9.1","min":0},"subtitle":"","author":["Eric S. Raymond"],"pubdate":"2006-2","tags":[{"count":2418,"name":"UNIX","title":"UNIX"},{"count":1107,"name":"编程","title":"编程"},{"count":907,"name":"编程艺术","title":"编程艺术"},{"count":684,"name":"计算机","title":"计算机"},{"count":378,"name":"文化","title":"文化"},{"count":371,"name":"programming","title":"programming"},{"count":311,"name":"linux","title":"linux"},{"count":292,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s1631790.jpg","binding":"平装","translator":["姜宏","何源","蔡晓俊"],"catalog":"","pages":"525","images":{"small":"https://img3.doubanio.com\/spic\/s1631790.jpg","large":"https://img3.doubanio.com\/lpic\/s1631790.jpg","medium":"https://img3.doubanio.com\/mpic\/s1631790.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1467587\/","id":"1467587","publisher":"电子工业出版社","isbn10":"7121021161","isbn13":"9787121021169","title":"UNIX编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/1467587","alt_title":"","author_intro":"","summary":"本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。","price":"59.00元"},{"rating":{"max":10,"numRaters":1125,"average":"8.7","min":0},"subtitle":"","author":["Jeremy Keith"],"pubdate":"2006年12月","tags":[{"count":1143,"name":"javascript","title":"javascript"},{"count":476,"name":"dom","title":"dom"},{"count":356,"name":"web开发","title":"web开发"},{"count":220,"name":"web","title":"web"},{"count":214,"name":"JavaScript","title":"JavaScript"},{"count":194,"name":"编程","title":"编程"},{"count":153,"name":"入门","title":"入门"},{"count":145,"name":"脚本语言","title":"脚本语言"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s1958902.jpg","binding":"简裝本","translator":["杨涛","王建桥","杨晓云"],"catalog":"第1章 javascript简史 1\n1.1　javascript的起源 2\n1.2　浏览器之争 3\n1.2.1　dhtml 3\n1.2.2　浏览器之间的冲突 4\n1.3　制定标准 5\n1.3.1　浏览器以外的考虑 5\n1.3.2　浏览器之争的结局 6\n1.3.3　新的开始 6\n1.4　小结 7\n第2章 javascript语法 9\n2.1　准备工作 9\n2.2　语法 11\n2.3　语句 11\n2.4　变量 13\n2.4.1　数据类型 15\n2.4.2　数组 17\n2.5　操作 20\n2.6　条件语句 22\n2.6.1　比较操作符 23\n.2.6.2　逻辑操作符 24\n2.7　循环语句 25\n2.7.1　while 25\n2.7.2　do...while 26\n2.7.3　for 27\n2.8　函数 27\n2.9　对象 31\n2.9.1　内建对象 32\n2.9.2　宿主对象 33\n2.10　小结 33\n第3章 dom 35\n3.1　文档：dom中的“d” 35\n3.2　对象：dom中的“o” 35\n3.3　模型：dom中的“m” 36\n3.3.1　节点 38\n3.3.2　getelementbyid()方法 42\n3.3.3　getelementsbytagname()方法 44\n3.4　趁热打铁 46\n3.4.1　getattribute()方法 46\n3.4.2　setattribute()方法 48\n3.5　小结 49\n第4章 案例研究：javascript美术馆 51\n4.1　编写标记语言文档 52\n4.2　编写javascript函数 54\n4.2.1　dom之前的解决方案 55\n4.2.2　showpic()函数的代码清单 56\n4.3　javascript函数的调用 56\n4.4　对javascript函数进行功能扩展 59\n4.4.1　childnodes属性 59\n4.4.2　nodetype属性 60\n4.4.3　在html文档里增加一段描述性文本 61\n4.4.4　用javascript代码改变＜p＞元素的文本内容 62\n4.4.5　nodevalue属性 63\n4.4.6　firstchild和lastchild属性 63\n4.4.7　利用nodevalue属性刷新＜p＞元素的文本内容 64\n4.5　小结 68\n第5章 javascript编程原则和良好习惯 69\n5.1　不要误解javascript 69\n5.1.1　不要归罪于javascript 70\n5.1.2　flash的遭遇 71\n5.1.3　质疑 72\n5.2　预留退路 72\n5.2.1　“javascript:”伪协议 74\n5.2.2　内嵌的事件处理函数 74\n5.2.3　有何不好 74\n5.3　向css学习 75\n5.4　分离javascript 78\n5.5　向后兼容性 80\n5.6　小结 82\n第6章 案例研究：javascript美术馆改进版 83\n6.1　快速回顾 84\n6.2　解决“预留退路”问题 84\n6.3　解决“分离javascript”问题 85\n6.3.1　添加事件处理函数 86\n6.3.2　进行必要的检查 87\n6.3.3　创建必要的变量 89\n6.3.4　创建循环 90\n6.3.5　完成必要的操作 91\n6.3.6　完成javascript函数 91\n6.3.7　把多个javascript函数绑定到onload事件处理函数上 92\n6.4　javascript函数的优化：不要做太多的假设 94\n6.4.1　不放过每个细节 97\n6.4.2　键盘浏览功能 99\n6.4.3　慎用onkeypress事件处理函数 100\n6.4.4　把javascript与css结合起来 102\n6.5　dom core和html-dom 105\n6.6　小结 106\n第7章 动态创建html内容 109\n7.1　document.write()方法 110\n7.2　innerhtml属性 111\n7.3　dom提供的方法 114\n7.3.1　createelement()方法 115\n7.3.2　appendchild()方法 116\n7.3.3　createtextnode()方法 117\n7.4　重回“javascript美术馆” 121\n7.4.1　insertbefore()方法 123\n7.4.2　“javascript美术馆”二次改进版 127\n7.5　小结 131\n7.6　下章简介 132\n第8章 充实文档的内容 133\n8.1 不应该做的事情 133\n8.2 把“不可见”变成“可见” 134\n8.3 原始内容 135\n8.4 xhtml文档 137\n8.5 css 138\n8.6 javascript代码 139\n8.6.1 显示“缩略词语表” 139\n8.6.2 显示“文献来源链接表” 152\n8.6.3 显示“快速访问键清单” 158\n8.7 小结 161\n8.8 下章简介 162\n第9章 css-dom 163\n9.1 三位一体的网页 163\n9.1.1 结构层 163\n9.1.2 表示层 164\n9.1.3 行为层 164\n9.1.4 分离 165\n9.2 style属性 165\n9.2.1 样式信息的检索 167\n9.2.2 设置样式信息 172\n9.3 何时该用dom脚本去设置样式信息 174\n9.3.1 根据元素在节点树里的位置来设置样式信息 174\n9.3.2 根据某种条件来设置样式信息 178\n9.3.3 对事件做出响应 182\n9.4 classname属性 184\n9.5 小结 188\n第10章 用javascript实现动画效果 191\n10.1 何为动画 191\n10.1.1 位置 192\n10.1.2 时间 194\n10.1.3 抽象化 198\n10.2 实用的动画 205\n10.2.1 问题的提出 205\n10.2.2 问题的解决 207\n10.2.3 css 208\n10.2.4 javascript代码 210\n10.2.5 与变量的作用域有关的问题 214\n10.3 改进动画效果 216\n10.4 最后的优化 219\n10.5 小结 224\n第11章 学以致用：javascript网站设计实战 225\n11.1 案例背景介绍 225\n11.1.1 原始材料 226\n11.1.2 网站的结构 226\n11.1.3 网页的结构 227\n11.2 页面视觉效果设计 228\n11.3 css 229\n11.4 颜色 231\n11.4.1 布局 232\n11.4.2 字型 234\n11.5 xhtml文档 236\n11.6 javascript脚本 236\n11.6.1 当前页面的标识 238\n11.6.2 javascript动画 242\n11.6.3 内部浏览 247\n11.6.4 javascript美术馆 251\n11.6.5 改进表格 254\n11.6.6 改进表单 259\n11.7 小结 268\n11.8 下章简介 268\n第12章 展望dom脚本编程技术 269\n12.1 web的现状 269\n12.1.1 web浏览器 270\n12.1.2 web设计师 271\n12.1.3 三条腿的凳子 272\n12.2 ajax技术 274\n12.2.1 xmlhttprequest对象 275\n12.2.2 ajax技术的爆发 278\n12.2.3 循序渐进：如何运用ajax技术 279\n12.2.4 ajax技术的未来 281\n12.3 web应用 282\n12.4 小结 283\n附录 dom方法和属性 285","pages":"316","images":{"small":"https://img3.doubanio.com\/spic\/s1958902.jpg","large":"https://img3.doubanio.com\/lpic\/s1958902.jpg","medium":"https://img3.doubanio.com\/mpic\/s1958902.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1921890\/","id":"1921890","publisher":"人民邮电出版社","isbn10":"7115139210","isbn13":"9787115139214","title":"JavaScript DOM编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/1921890","alt_title":"","author_intro":"","summary":"本书讲述了JavaScript和DOM的基础知识，但重点放在DOM编程技术背后的思路和原则：预留退路、循序渐进和以用户为中心等，这些概念对于任何前端Web开发工作都非常重要。本书将这些概念贯穿在书中的所有代码示例中，使你看到用来创建图片库页面的脚本、用来创建动画效果的脚本和用来丰富页面元素呈现效果的脚本，最后结合所讲述的内容创建了一个实际的网站。\n本书适合Web设计师和开发人员阅读。","series":{"id":"28503","title":"图灵程序设计丛书·Web开发系列"},"price":"39.00元"},{"rating":{"max":10,"numRaters":1208,"average":"8.7","min":0},"subtitle":"","author":["[英] Jeremy Keith","[加] Jeffrey Sambells"],"pubdate":"2011-4","tags":[{"count":829,"name":"javascript","title":"javascript"},{"count":563,"name":"前端开发","title":"前端开发"},{"count":483,"name":"JavaScript","title":"JavaScript"},{"count":285,"name":"dom","title":"dom"},{"count":284,"name":"前端","title":"前端"},{"count":219,"name":"编程","title":"编程"},{"count":154,"name":"Web","title":"Web"},{"count":151,"name":"web开发","title":"web开发"}],"origin_title":"DOM Scripting: Web Design with JavaScript and the Document Object Model","image":"https://img3.doubanio.com\/mpic\/s4677623.jpg","binding":"平装","translator":["杨涛","王建桥","杨晓云 等"],"catalog":"第1章 JavaScript简史\t1\n1.1 JavaScript的起源\t1\n1.2 DOM\t2\n1.3 浏览器战争\t3\n1.3.1 DHTML\t3\n1.3.2 浏览器之间的冲突\t3\n1.4 制定标准\t4\n1.4.1 浏览器以外的考虑\t4\n1.4.2 浏览器战争的结局\t5\n1.4.3 崭新的起点\t5\n1.5 小结\t6\n第2章 JavaScript语法\t8\n2.1 准备工作\t8\n2.2 语法\t10\n2.2.1 语句\t10\n2.2.2 注释\t10\n2.2.3 变量\t11\n2.2.4 数据类型\t14\n2.2.5 数组\t16\n2.2.6 对象\t18\n2.3 操作\t19\n2.4 条件语句\t21\n2.4.1 比较操作符\t22\n2.4.2 逻辑操作符\t23\n2.5 循环语句\t24\n2.5.1 while循环\t24\n2.5.2 for循环\t25\n2.6 函数\t26\n2.7 对象\t29\n2.7.1 内建对象\t30\n2.7.2 宿主对象\t31\n2.8 小结\t31\n第3章 DOM\t32\n3.1 文档：DOM中的“D”\t32\n3.2 对象：DOM中的“O”\t32\n3.3 模型：DOM中的“M”\t33\n3.4 节点\t35\n3.4.1 元素节点\t35\n3.4.2 文本节点\t35\n3.4.3 属性节点\t36\n3.4.4 CSS\t36\n3.4.5 获取元素\t38\n3.4.6 盘点知识点\t42\n3.5 获取和设置属性\t43\n3.5.1 getAttribute\t43\n3.5.2 setAttribute\t44\n3.6 小结\t45\n第4章 案例研究：JavaScript图片库\t46\n4.1 标记\t46\n4.2 JavaScript\t48\n4.2.1 非DOM解决方案\t49\n4.2.2 最终的函数代码清单\t50\n4.3 应用这个JavaScript函数\t50\n4.4 对这个函数进行扩展\t52\n4.4.1 childNodes属性\t53\n4.4.2 nodeType属性\t54\n4.4.3 在标记里增加一段描述\t54\n4.4.4 用JavaScript改变这段描述\t55\n4.4.5 nodeValue属性\t56\n4.4.6 firstChild和lastChild属性\t56\n4.4.7 利用nodeValue属性刷新这段描述\t57\n4.5 小结\t60\n第5章 最佳实践\t61\n5.1 过去的错误\t61\n5.1.1 不要怪罪JavaScript\t61\n5.1.2 Flash的遭遇\t62\n5.1.3 质疑一切\t63\n5.2 平稳退化\t63\n5.2.1 “javascript:”伪协议\t64\n5.2.2 内嵌的事件处理函数\t65\n5.2.3 谁关心这个\t65\n5.3 向CSS学习\t66\n5.3.1 结构与样式的分离\t66\n5.3.2 渐进增强\t67\n5.4 分离JavaScript\t68\n5.5 向后兼容\t70\n5.5.1 对象检测\t70\n5.5.2 浏览器嗅探技术\t71\n5.6 性能考虑\t72\n5.6.1 尽量少访问DOM和尽量减少标记\t72\n5.6.2 合并和放置脚本\t73\n5.6.3 压缩脚本\t73\n5.7 小结\t74\n第6章 案例研究：图片库改进版\t75\n6.1 快速回顾\t75\n6.2 它支持平稳退化吗\t76\n6.3 它的JavaScript与HTML标记是分离的吗\t77\n6.3.1 添加事件处理函数\t77\n6.3.2 共享onload事件\t82\n6.4 不要做太多的假设\t84\n6.5 优化\t86\n6.6 键盘访问\t88\n6.7 把JavaScript与CSS结合起来\t90\n6.8 DOM Core和HTML-DOM\t93\n6.9 小结\t94\n第7章 动态创建标记\t96\n7.1 一些传统方法\t96\n7.1.1 document.write\t96\n7.1.2 innerHTML属性\t98\n7.2 DOM方法\t101\n7.2.1 createElement方法\t101\n7.2.2 appendChild方法\t102\n7.2.3 createTextNode方法\t103\n7.2.4 一个更复杂的组合\t105\n7.3 重回图片库\t107\n7.3.1 在已有元素前插入一个新元素\t108\n7.3.2 在现有方法后插入一个新元素\t109\n7.3.3 图片库二次改进版\t111\n7.4 Ajax\t114\n7.4.1 XMLHttpRequest对象\t115\n7.4.2 渐进增强与Ajax\t119\n7.4.3 Hijax\t120\n7.5 小结\t121\n第8章 充实文档的内容\t122\n8.1 不应该做什么\t122\n8.2 把“不可见”变成“可见”\t123\n8.3 内容\t123\n8.3.1 选用HTML、XHTML还是HTML5\t124\n8.3.2 CSS\t126\n8.3.3 JavaScript\t127\n8.4 显示“缩略语列表”\t127\n8.4.1 编写displayAbbreviations函数\t128\n8.4.2 创建标记\t130\n8.4.3 一个浏览器“地雷”\t135\n8.5 显示“文献来源链接表”\t138\n8.6 显示“快捷键清单”\t143\n8.7 检索和添加信息\t146\n8.8 小结\t147\n第9章 CSS-DOM\t148\n9.1 三位一体的网页\t148\n9.1.1 结构层\t148\n9.1.2 表示层\t148\n9.1.3 行为层\t149\n9.1.4 分离\t150\n9.2 style属性\t150\n9.2.1 获取样式\t151\n9.2.2 设置样式\t156\n9.3 何时该用DOM脚本设置样式\t158\n9.3.1 根据元素在节点树里的位置来设置样式\t158\n9.3.2 根据某种条件反复设置某种样式\t161\n9.3.3 响应事件\t165\n9.4 className属性\t167\n9.5 小结\t171\n第10章 用JavaScript实现动画效果\t172\n10.1 动画基础知识\t172\n10.1.1 位置\t172\n10.1.2 时间\t175\n10.1.3 时间递增量\t175\n10.1.4 抽象\t178\n10.2 实用的动画\t184\n10.2.1 提出问题\t184\n10.2.2 解决问题\t186\n10.2.3 CSS\t187\n10.2.4 JavaScript\t189\n10.2.5 变量作用域问题\t192\n10.2.6 改进动画效果\t193\n10.2.7 添加安全检查\t196\n10.2.8 生成HTML标记\t198\n10.3 小结\t200\n第11章 HTML5\t201\n11.1 HTML5简介\t201\n11.2 来自朋友的忠告\t203\n11.3 几个示例\t204\n11.3.1 Canvas\t205\n11.3.2 音频和视频\t209\n11.3.3 表单\t215\n11.4 HTML5还有其他特性吗\t219\n11.5 小结\t219\n第12章 综合示例\t220\n12.1 项目简介\t220\n12.1.1 原始资料\t220\n12.1.2 站点结构\t220\n12.1.3 页面结构\t221\n12.2 设计\t222\n12.3 CSS\t223\n12.3.1 颜色\t225\n12.3.2 布局\t226\n12.3.3 版式\t228\n12.4 标记\t229\n12.5 JavaScript\t230\n12.5.1 页面突出显示\t231\n12.5.2 JavaScript幻灯片\t235\n12.5.3 内部导航\t239\n12.5.4 JavaScript图片库\t242\n12.5.5 增强表格\t245\n12.5.6 增强表单\t249\n12.5.7 压缩代码\t263\n12.6 小结\t264\n附录 JavaScript库\t265","pages":"300","images":{"small":"https://img3.doubanio.com\/spic\/s4677623.jpg","large":"https://img3.doubanio.com\/lpic\/s4677623.jpg","medium":"https://img3.doubanio.com\/mpic\/s4677623.jpg"},"alt":"https:\/\/book.douban.com\/subject\/6038371\/","id":"6038371","publisher":"人民邮电出版社","isbn10":"7115249997","isbn13":"9787115249999","title":"JavaScript DOM编程艺术 （第2版）","url":"https:\/\/api.douban.com\/v2\/book\/6038371","alt_title":"DOM Scripting: Web Design with JavaScript and the Document Object Model","author_intro":"Jeremy Keith  国际知名的Web设计师，Web标准项目组成员，DOM Scripting任务组负责人之一，任职于Web咨询公司Clearleft。除本书外，还著有HTML5 for Web Designers、Bulletproof Ajax。可通过其个人网站adactio.com与他联系。\nJeffrey Sambells 资深平面设计师，Web开发人员，创办了软件公司We-Create并担任研发总监。除本书外，还著有《JavaScript高级程序设计》和 Beginning Google Maps Applications with PHP and Ajax等多部畅销书。","summary":"JavaScript是Web开发中最重要的一门语言，它强大而优美。无论是桌面开发，还是移动应用。JavaScript都是必须掌握的技术。W3C的DOM标准是开发Web应用的基石。已经得到所有现代浏览器的支持，这使得跨平台Web开发成了一件轻松惬意的事。\n本书是超级畅销书的升级版，由倡导Web标准的领军人物执笔，揭示了前端开发的真谛，是学习JavaScript和DOM开发的必读之作。\n本 书在简洁明快地讲述JavaScript和DOM的基本知识之后，通过几个实例演示了专业水准的网页开发技术，透彻阐述了平稳退化等一批至关重要的 JavaScript编程原则和最佳实践，并全面探讨了HTML5以及jQuery等JavaScript库。读者将看到JavaScript、 HTML5和CSS如何协作来创建易用的、与标准兼容的Web设计，掌握使用JavaScript和DOM通过客户端动态效果和用户控制的动画来加强 Web页面的必备技术；同时，还将对如何利用库提高开发效率有全面深入的理解。","series":{"id":"660","title":"图灵程序设计丛书"},"price":"49.00元"},{"rating":{"max":10,"numRaters":185,"average":"7.0","min":0},"subtitle":"","author":["谭亮"],"pubdate":"2011-6","tags":[{"count":262,"name":"processing","title":"processing"},{"count":168,"name":"交互设计","title":"交互设计"},{"count":103,"name":"编程","title":"编程"},{"count":88,"name":"设计","title":"设计"},{"count":84,"name":"新媒体","title":"新媒体"},{"count":67,"name":"艺术","title":"艺术"},{"count":45,"name":"Processing","title":"Processing"},{"count":30,"name":"新媒介","title":"新媒介"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s6514269.jpg","binding":"","translator":[],"catalog":"目 录\n第1章 认识Processing 1\n1.1 Processing是什么 2\n1.2 Processing的诞生 3\n1.2.1 MIT与约翰•梅达 3\n1.2.2 Casey Reas和Ben Fry 6\n1.3 Processing能做什么 8\n1.3.1 数据视觉化 8\n1.3.2 生成艺术 10\n1.3.3 互动艺术 14\n第2章 使用Processing 17\n2.1 下载与安装 17\n2.2 开发环境 18\n2.2.1 开发环境界面 18\n2.2.2 快捷按钮 20\n2.3 语法结构 20\n2.3.1 基本语句 21\n2.3.2 代码编写流程 22\n2.3.3 注释 22\n2.3.4 表达式和陈述 23\n2.3.5 控制台 24\n2.4 变量 24\n2.4.1 声明一个变量 25\n2.4.2 变量的类型 26\n2.4.3 系统变量 27\n2.5 符号与条件式 28\n2.5.1 布尔表达式 28\n2.5.2 算术运算符 28\n2.5.3 关系操作符 29\n2.5.4 逻辑操作符 29\n2.5.5 条件式——if、else和else if 33\n本章作业 36\n第3章 绘画 39\n3.1 画布与坐标 39\n3.1.1 像素与画布 39\n3.1.2 直角坐标与计算机屏幕坐标 40\n3.2 图形 41\n3.2.1 点 41\n3.2.2 直线 42\n3.2.3 矩形 42\n3.2.4 圆与圆弧形 43\n3.2.5 三角形与四边形 45\n3.2.6 贝塞尔曲线 46\n3.2.7 自由图形 47\n3.3 色彩 49\n3.3.1 灰阶与透明度 50\n3.3.2 RGB色彩 52\n3.3.3 HSB色彩 53\n3.4 绘画属性设定 55\n3.4.1 填色与边框 55\n3.4.2 图形的顺序 56\n3.5 重复绘画 58\n3.5.1 简单的重复 58\n3.5.2 迭代法与while循环 59\n3.5.3 for 循环 60\n3.6 PDF输出与绘画实例 62\n3.6.1 PDF格式输出 62\n3.6.2 绘画实例 63\n3.6.3 学生作品欣赏 64\n本章作业 66\n第4章 响应互动 67\n4.1 鼠标响应 67\n4.1.1 鼠标移动响应mouseX 和 mouseY 67\n4.1.2 pmouseX和pmouseY 70\n4.1.3 鼠标响应事件 72\n4.2 键盘响应 75\n4.2.1 按击键响应 75\n4.2.2 特定按键响应 78\n4.2.3 功能键响应 79\n4.3 随机random 80\n4.4 限制constrain 83\n本章作业 84\n第5章 动画 85\n5.1 运动的产生 85\n5.1.1 变量控制运动 85\n5.1.2 条件句控制运动 86\n5.1.3 加速与减速 87\n5.2 随机运动 89\n5.3 曲线轨迹运动 90\n5.4 坐标转移、旋转与缩放 95\n5.4.1 坐标转移 95\n5.4.2 旋转运动 96\n5.4.3 缩放运动 99\n5.5 pushMatrix() 与 popMatrix() 100\n5.6 时间控制 102\n本章作业 103\n第6章 函数与对象 105\n6.1 函数 105\n6.1.1 定义函数 105\n6.1.2 调用函数 109\n6.1.3 函数与循环 111\n6.1.4 函数返回类型 114\n6.2 类与对象 115\n6.2.1 面向对象的程序设计 115\n6.2.2 定义类 116\n6.2.3 创建对象 119\n6.2.4 构造器的引数 121\n本章作业 124\n第7章 数组 125\n7.1 变量列数组 127\n7.1.1 声明变量列数组 127\n7.1.2 定义数组的长度 128\n7.1.3 给数组赋值 128\n7.2 变量列数组实例 130\n7.3 对象的数组 134\n本章作业 137\n第8章 图片与文字 139\n8.1 图片 139\n8.1.1 显示图片 139\n8.1.2 图片互动 143\n8.1.3 图片色彩设置 144\n8.2 文字 147\n8.2.1 使用字体 147\n8.2.2 字符串 148\n本章作业 150\n第9章 视频 151\n9.1 播放视频文件 151\n9.2 实时视频输入 155\n9.3 视频互动特效 158\n9.3.1 互动色彩调整 158\n9.3.2 视频马赛克 159\n9.3.3 色彩捕捉 161\n9.3.4 版画效果 166\n本章作业 169\n第10章 Minim音频 171\n10.1 播放音频 171\n10.2 声音的视觉化 173\n10.3 音频输入互动 179\n本章作业 181\n第11章 3D 183\n11.1 3D简介 183\n11.2 3D图形 184\n11.3 3D空间旋转 185\n11.4 3D互动 187\n11.5 参考案例 190\n本章作业 192\n第12章 Arduino与物理计算 193\n12.1 Arduino简介 193\n12.2 Arduino与开关 195\n12.3 Arduino与传感器 197\n12.4 光敏传感器 200\n本章作业 202\n附录A 203\n后记 205\n参考书目 206","pages":"220","images":{"small":"https://img1.doubanio.com\/spic\/s6514269.jpg","large":"https://img1.doubanio.com\/lpic\/s6514269.jpg","medium":"https://img1.doubanio.com\/mpic\/s6514269.jpg"},"alt":"https:\/\/book.douban.com\/subject\/6517501\/","id":"6517501","publisher":"电子工业出版社","isbn10":"7121134632","isbn13":"9787121134630","title":"Processing互动编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/6517501","alt_title":"","author_intro":"谭亮，2004年至今任教于广州美术学院新媒介艺术专业，致力于互动艺术、编程艺术教学与研究。2005年作品参加日本爱知世界博览会中国馆数字艺术项目。2007年赴德国柏林设计学院信息设计系交流，“城市突变”国际工作坊指导教师。2008年在英国文化协会主办的“香港48小时和合设计竞赛”中获得Best Design奖。2009年赴法国埃克斯•普罗旺斯艺术学院访问学习。","summary":"内容简介\n本书将引领你进入编程艺术的世界。本书揭示了运用Processing创建高质量互动艺术作品的奥秘，你将感受到Processing的敏捷性和艺术性，内容覆盖绘图、响应互动、动画、视频、3D、物理计算等专题。精选的实例将激发读者的想象力和创造的乐趣，阅读和练习本书的案例即能快速进入互动艺术创作。本书语言简洁易懂，案例设计独特，所有代码均可在线下载，适合于专业编程人员和学习互动艺术的读者。\n前 言\n编程，即计算机程序设计，是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。也许有人认为编程课程只适合于理工类专业，对艺术设计类专业来讲似乎意义不大，实际上并非这样。程序设计技术的先驱者唐纳德·克努特认为，程序设计既是一门科学，也是一门艺术，这两方面可以彼此很好地相互补充。科学的方法一般是通过“逻辑的”、“系统的”、“非个人的”、“冷静的”、“理性的”这些词来表征的，而艺术的方法是通过“艺术的”、“创新的”、“博爱的”、“渴望的”、“非理性的”这些词来表征的。\n2009年11月，英国伦敦V&A博物馆“数字设计感官展”展出了大量由计算机程序生成的互动艺术作品，展览打破了作品静态呈现的传统展示方式，颠覆了观众静观作品的观看惯性。计算机程序对艺术的介入引发了艺术家创作工具和思维方式的转变。研究如何编写程序、创造声音或图像的界面以实现代码与观众之间的交流互动，成为设计艺术界新的课题。美国排名前列的罗德岛设计学院聘请麻省理工媒体实验室ACG小组主任约翰·梅达担任校长，传统的艺术设计行业正面临着一场革命。编写程序不仅是程序员的专利，它也已成为数字艺术家的创作手段，以及艺术院校的必修课程。英国皇家艺术学院、耶鲁大学设计学院、加州大学媒体艺术专业、卡内基梅隆大学等院校都把编程作为教学课题。\n大部分设计师都会使用商业软件（如 Photoshop、Illustrator、Flash）来从事创作，这些软件功能丰富、使用方便，可以实现预设的效果。但人们的创意和表现形式往往被企业所主导的制式化生产工具所限制。Processing的出现是艺术设计创作的一场革命，它是一种具有前瞻性的新兴计算机语言，用户主要面向计算机程序员和数字艺术家。艺术家可以运用Processing生成唯美的图形，为互动艺术作品编写程序，将抽象的数据呈现为视觉形象。当你进入到互动编程艺术的世界，就会发现这一切都是让人兴奋不已的。\n由于文化和语言的差异，国内研究Processing的学术机构并不多见，中文网站和学术论坛等学习资源有限，也没有相关的中文版本的书籍。资料的缺乏在很大程度上降低了中国设计师学习Processing的积极性。鉴于以上现实，作者根据自身的教学实践编写了本书。本书可作为学习互动艺术编程的基础书籍，主要面向艺术院校数字媒体设计专业、交互设计专业，以及业界的设计师，等等。本书前两章主要介绍了Processing的背景、编程与互动艺术的关系，以及编程基础知识。接下来的章节对绘画、互动、动画、函数与对象、数组、图片与文字、视频与音频、3D与物理计算等方面进行了较为全面的论述，并结合了大量的实例与作品分析来启发读者的互动艺术思维。在国内，互动艺术和编程艺术都是新的研究领域，本书是在一个全新的领域中进行探索，在此过程中难免会存在不完善之处，希望得到相关专家和广大读者的批评指正！\n在创意产业迅速发展的中国，我们有理由相信新一代的艺术家和设计师们不会只停留在软件应用的层次，他们会运用编程去创新、发展艺术与设计，并将民族文化与思想注入到作品中！\n作者：谭亮\n2011年5月于广州","price":"39.00元"},{"rating":{"max":10,"numRaters":244,"average":"9.0","min":0},"subtitle":"","author":["Eric S. Raymond"],"pubdate":"2011-1","tags":[{"count":353,"name":"UNIX","title":"UNIX"},{"count":226,"name":"编程","title":"编程"},{"count":130,"name":"哲学","title":"哲学"},{"count":109,"name":"计算机","title":"计算机"},{"count":106,"name":"程序设计","title":"程序设计"},{"count":90,"name":"经典","title":"经典"},{"count":79,"name":"计算机科学","title":"计算机科学"},{"count":65,"name":"Linux","title":"Linux"}],"origin_title":"The Art of UNIX Programming","image":"https://img3.doubanio.com\/mpic\/s6476712.jpg","binding":"","translator":["姜宏","何源","蔡晓俊"],"catalog":"序 xxv\npart i 1\n第1章 哲学 3\n1.1 文化？什么文化 3\n1.2 unix的生命力 4\n1.3 反对学习unix文化的理由 5\n1.4 unix之失 6\n1.5 unix之得 7\n1.5.1 开源软件 7\n1.5.2 跨平台可移植性和开放标准 8\n1.5.3 internet和万维网 8\n1.5.4 开源社区 9\n1.5.5 从头到脚的灵活性 9\n1.5.6 unix hack之趣 10\n1.5.7 unix的经验别处也可适用 11\n1.6 unix哲学基础 11\n1.6.1 模块原则：使用简洁的接口拼合简单的部件 14\n1.6.2 清晰原则: 清晰胜于机巧 14\n1.6.3 组合原则：设计时考虑拼接组合 15\n1.6.4 分离原则: 策略同机制分离，接口同引擎分离 16\n.1.6.5 简洁原则：设计要简洁，复杂度能低则低 17\n1.6.6 吝啬原则: 除非确无它法，不要编写庞大的程序 18\n1.6.7 透明性原则：设计要可见，以便审查和调试 18\n1.6.8 健壮原则: 健壮源于透明与简洁 18\n1.6.9 表示原则: 把知识叠入数据以求逻辑质朴而健壮 19\n1.6.10 通俗原则：接口设计避免标新立异 20\n1.6.11 缄默原则：如果一个程序没什么好说的，就保持沉默 20\n1.6.12 补救原则: 出现异常时，马上退出并给出足量错误信息 21\n1.6.13 经济原则: 宁花机器一分，不花程序员一秒 22\n1.6.14 生成原则: 避免手工hack，尽量编写程序去生成程序 22\n1.6.15 优化原则: 雕琢前先得有原型，跑之前先学会走 23\n1.6.16 多样原则:决不相信所谓“不二法门”的断言 24\n1.6.17 扩展原则: 设计着眼未来，未来总比预想快 24\n1.7 unix哲学之一言以蔽之 25\n1.8 应用unix哲学 26\n1.9 态度也要紧 26\n第2章 历史——双流记 29\n2.1 unix的起源及历史，1969－1995 29\n2.1.1 创世纪：1969－1971 30\n2.1.2 出埃及记：1971－1980 32\n2.1.3 tcp\/ip 和unix内战：1980－1990 35\n2.1.4 反击帝国：1991－1995 41\n2.2 黑客的起源和历史：1961－1995 43\n2.2.1 游戏在校园的林间：1961－1980 44\n2.2.2 互联网大融合与自由软件运动：1981－1991 45\n2.2.3 linux 和实用主义者的应对：1991－1998 48\n2.3 开源运动：1998年及之后 49\n2.4 unix的历史教训 51\n第3章 对比： unix哲学同其他哲学的比较 53\n3.1 操作系统的风格元素 53\n3.1.1 什么是操作系统的统一性理念 54\n3.1.2 多任务能力 54\n3.1.3 协作进程 55\n3.1.4 内部边界 57\n3.1.5 文件属性和记录结构 57\n3.1.6 二进制文件格式 58\n3.1.7 首选用户界面风格 58\n3.1.8 目标受众 59\n3.1.9 开发的门坎 60\n3.2 操作系统的比较 61\n3.2.1 vms 61\n3.2.2 macos 64\n3.2.3 os\/2 65\n3.2.4 windows nt 68\n3.2.5 beos 71\n3.2.6 mvs 72\n3.2.7 vm\/cms 74\n3.2.8 linux 76\n3.3 种什么籽，得什么果 78\npart ii 81\n第4章 模块性：保持清晰，保持简洁 83\n4.1 封装和最佳模块大小 85\n4.2 紧凑性和正交性 87\n4.2.1 紧凑性 87\n4.2.2 正交性 89\n4.2.3 spot原则 91\n4.2.4 紧凑性和强单一中心 92\n4.2.5 分离的价值 94\n4.3 软件是多层的 95\n4.3.1 自顶向下和自底向上 95\n4.3.2 胶合层 97\n4.3.3 实例分析：被视为薄胶合层的c语言 98\n4.4 程序库 99\n4.4.1 实例分析：gimp插件 100\n4.5 unix和面向对象语言 101\n4.6 模块式编码 103\n第5章 文本化：好协议产生好实践 105\n5.1 文本化的重要性 107\n5.1.1 实例分析：unix口令文件格式 109\n5.1.2 实例分析：.newsrc格式 110\n5.1.3 实例分析：png图形文件格式 111\n5.2 数据文件元格式 112\n5.2.1 dsv 风格 113\n5.2.2 rfc 822 格式 114\n5.2.3 cookie-jar格式 115\n5.2.4 record-jar格式 116\n5.2.5 xml 117\n5.2.6 windows ini 格式 119\n5.2.7 unix文本文件格式的约定 120\n5.2.8 文件压缩的利弊 122\n5.3 应用协议设计 123\n5.3.1 实例分析：smtp，一个简单的套接字协议 124\n5.3.2 实例分析：pop3，邮局协议 124\n5.3.3 实例分析：imap，互联网消息访问协议 126\n5.4 应用协议元格式 127\n5.4.1 经典的互联网应用元协议 127\n5.4.2 作为通用应用协议的http 128\n5.4.3 beep：块可扩展交换协议 130\n5.4.4 xml-rpc，soap和jabber 131\n第6章 透明性：来点儿光 133\n6.1 研究实例 135\n6.1.1 实例分析：audacity 135\n6.1.2 实例分析：fetchmail的–v选项 136\n6.1.3 实例分析：gcc 139\n6.1.4 实例分析：kmail 140\n6.1.5 实例分析：sng 142\n6.1.6 实例分析：terminfo数据库 144\n6.1.7 实例分析：freeciv数据文件 146\n6.2 为透明性和可显性而设计 148\n6.2.1 透明性之禅 149\n6.2.2 为透明性和可显性而编码 150\n6.2.3 透明性和避免过度保护 151\n6.2.4 透明性和可编辑的表现形式 152\n6.2.5 透明性、故障诊断和故障恢复 153\n6.3 为可维护性而设计 154\n第7章 多道程序设计： 分离进程为独立的功能 157\n7.1 从性能调整中分离复杂度控制 159\n7.2 unix ipc 方法的分类 160\n7.2.1 把任务转给专门程序 160\n7.2.2 管道、重定向和过滤器 161\n7.2.3 包装器 166\n7.2.4 安全性包装器和bernstein链 167\n7.2.5 从进程 168\n7.2.6 对等进程间通信 169\n7.3 要避免的问题和方法 176\n7.3.1 废弃的unix ipc方法 176\n7.3.2 远程过程调用 178\n7.3.3 线程——恐吓或威胁 180\n7.4 在设计层次上的进程划分 181\n第8章 微型语言：寻找歌唱的乐符 183\n8.1 理解语言分类法 185\n8.2 应用微型语言 187\n8.2.1 案例分析：sng 187\n8.2.2 案例分析：正则表达式 188\n8.2.3 案例分析：glade 191\n8.2.4 案例分析：m4 193\n8.2.5 案例分析：xslt 194\n8.2.6 案例分析：the documenter's workbench tools 195\n8.2.7 案例分析：fetchmail的运行控制语法 199\n8.2.8 案例分析：awk 200\n8.2.9 案例分析：postscript 202\n8.2.10 案例分析：bc和dc 203\n8.2.11 案例分析：emacs lisp 205\n8.2.12 案例分析：javascript 205\n8.3 设计微型语言 206\n8.3.1 选择正确的复杂度 207\n8.3.2 扩展和嵌入语言 209\n8.3.3 编写自定义语法 210\n8.3.4 宏—慎用 210\n8.3.5 语言还是应用协议 212\n第9章 生成：提升规格说明的层次 215\n9.1 数据驱动编程 216\n9.1.1 实例分析：ascii 217\n9.1.2 实例分析：统计学的垃圾邮件统计 218\n9.1.3 实例分析：fetchmailconf中的元类改动 219\n9.2 专用代码的生成 225\n9.2.1 实例分析：生成ascii显示的代码 225\n9.2.2 实例分析：为列表生成html代码 227\n第10章 配置：迈出正确的第一步 231\n10.1 什么应是可配置的 231\n10.2 配置在哪里 233\n10.3 运行控制文件 234\n10.3.1 实例分析：.netrc文件 236\n10.3.2 到其它操作系统的可移植性 238\n10.4 环境变量 238\n10.4.1 系统环境变量 238\n10.4.2 用户环境变量 240\n10.4.3 何时使用环境变量 240\n10.4.4 到其它操作系统的可移植性 242\n10.5 命令行选项 242\n10.5.1 从–a到–z的命令行选项 243\n10.5.2 到其它操作系统的可移植性 248\n10.6 如何挑选方法 248\n10.6.1 实例分析：fetchmail 249\n10.6.2 实例分析：xfree86服务器 251\n10.7 论打破规则 252\n第11章 接口：unix环境下的用户接口设计模式 253\n11.1 最小立异原则的应用 254\n11.2 unix接口设计的历史 256\n11.3 接口设计评估 257\n11.4 cli和可视接口之间的权衡 259\n11.4.1 实例分析：编写计算器程序的两种方式 262\n11.5 透明度、表现力和可配置性 264\n11.6 unix接口设计模式 266\n11.6.1 过滤器模式 266\n11.6.2 cantrip模式 268\n11.6.3 源模式 268\n11.6.4 接收器模式 269\n11.6.5 编译器模式 269\n11.6.6 ed模式 270\n11.6.7 roguelike 模式 270\n11.6.8 “引擎和接口分离”模式 273\n11.6.9 cli服务器模式 278\n11.6.10 基于语言的接口模式 279\n11.7 应用unix接口设计模式 280\n11.7.1\n11.8 网页浏览器作为通用前端 281\n11.9 沉默是金 284\n第12章 优化 287\n12.1 什么也别做，就站在那儿 287\n12.2 先估量，后优化 288\n12.3 非定域性之害 290\n12.4 吞吐量和延迟 291\n12.4.1 批操作 292\n12.4.2 重叠操作 293\n12.4.3 缓存操作结果 293\n第13章 复杂度：尽可能简单，但别简过了头 295\n13.1 谈谈复杂度 296\n13.1.1 复杂度的三个来源 296\n13.1.2 接口复杂度和实现复杂度的折中 298\n13.1.3 必然的、可能的和偶然的复杂度 299\n13.1.4 映射复杂度 300\n13.1.5 当简洁性不能胜任 302\n13.2 五个编辑器的故事 302\n13.2.1 ed 304\n13.2.2 vi 305\n13.2.3 sam 306\n13.2.4 emacs 307\n13.2.5 wily 308\n13.3 编辑器的适当规模 309\n13.3.1 甄别复杂度问题 309\n13.3.2 折衷无用 312\n13.3.3 emacs是个反unix传统的论据吗 314\n13.4 软件的适度规模 316\npart iii 319\n第14章 语言：c还是非c 321\n14.1 unix下语言的丰饶 321\n14.2 为什么不是c 323\n14.3 解释型语言和混合策略 325\n14.4 语言评估 325\n14.4.1 c 326\n14.4.2 c++ 327\n14.4.3 shell 330\n14.4.4 perl 332\n14.4.5 tcl 334\n14.4.6 python 336\n14.4.7 java 339\n14.4.8 emacs lisp 342\n14.5 未来趋势 344\n14.6 选择x工具包 346\n第15章 工具：开发的战术 349\n15.1 开发者友好的操作系统 349\n15.2 编辑器选择 350\n15.2.1 了解vi 351\n15.2.2 了解emacs 351\n15.2.3 非虔诚的选择：两者兼用 352\n15.3 专用代码生成器 352\n15.3.1 yacc和lex 353\n15.3.2 实例分析：fetchmailrc的语法 356\n15.3.3 实例分析：glade 356\n15.4 make：自动化编译 357\n15.4.1 make的基本理论 357\n15.4.2 非c\/c++开发中的make 359\n15.4.3 通用生成目标 359\n15.4.4 生成makefile 362\n15.5 版本控制系统 364\n15.5.1 为什么需要版本控制 364\n15.5.2 手工版本控制 365\n15.5.3 自动化的版本控制 366\n15.5.4 unix的版本控制工具 367\n15.6 运行期调试 369\n15.7 性能分析 370\n15.8 使用emacs整合工具 370\n15.8.1 emacs和make 371\n15.8.2 emacs和运行期调试 371\n15.8.3 emacs和版本控制 371\n15.8.4 emacs和profiling 372\n15.8.5 像ide一样，但更强 373\n第16章 重用：论不要重新发明轮子 375\n16.1 猪小兵的故事 376\n16.2 透明性是重用的关键 379\n16.3 从重用到开源 380\n16.4 生命中最美好的就是“开放” 381\n16.5 何处找 384\n16.6 使用开源软件的问题 385\n16.7 许可证问题 386\n16.7.1 开放源码的资格 386\n16.7.2 标准开放源码许可证 388\n16.7.3 何时需要律师 390\npart iv 391\n第17章 可移植性：软件可移植性与遵循标准 393\n17.1 c语言的演化 394\n17.1.1 早期的c语言 395\n17.1.2 c 语言标准 396\n17.2 unix 标准 398\n17.2.1 标准和unix之战 398\n17.2.2 庆功宴上的幽灵 401\n17.2.3 开源世界的unix标准 402\n17.3 ietf和rfc标准化过程 403\n17.4 规格dna，代码rna 405\n17.5 可移植性编程 408\n17.5.1 可移植性和编程语言选择 409\n17.5.2 避免系统依赖性 412\n17.5.3 移植工具 413\n17.6 国际化 413\n17.7 可移植性、开放标准以及开放源码 414\n第18章 文档：向网络世界阐释代码 417\n18.1 文档概念 418\n18.2 unix风格 420\n18.2.1 大文档偏爱 420\n18.2.2 文化风格 421\n18.3 各种unix文档格式 422\n18.3.1 troff和documenter's workbench tools 422\n18.3.2 tex 424\n18.3.3 texinfo 425\n18.3.4 pod 425\n18.3.5 html 426\n18.3.6 docbook 426\n18.4 当前的混乱和可能的出路 426\n18.5 docbook 427\n18.5.1 文档类型定义 427\n18.5.2 其它dtd 428\n18.5.3 docbook 工具链 429\n18.5.4 移植工具 431\n18.5.5 编辑工具 432\n18.5.6 相关标准和实践 433\n18.5.7 sgml 433\n18.5.8 xml-docbook 参考书籍 433\n18.6 编写unix文档的最佳实践 434\n第19章 开放源码：在unix新社区中编程 437\n19.1 unix和开放源码 438\n19.2 与开源开发者协同工作的最佳实践 440\n19.2.1 良好的修补实践 440\n19.2.2 良好的项目、档案文件命名实践 444\n19.2.3 良好的开发实践 447\n19.2.4 良好的发行制作实践 450\n19.2.5 良好的交流实践 454\n19.3 许可证的逻辑：如何挑选 456\n19.4 为什么应使用某个标准许可证 457\n19.5 各种开源许可证 457\n19.5.1 mit或者x consortium许可证 457\n19.5.2 经典bsd许可证 457\n19.5.3 artistic许可证 458\n19.5.4 通用公共许可证 458\n19.5.5 mozilla 公共许可证 459\n第20章 未来：危机与机遇 461\n20.1 unix传统中的必然和偶然 461\n20.2 plan 9：未来之路 464\n20.3 unix设计中的问题 466\n20.3.1 unix文件就是一大袋字节 466\n20.3.2 unix对gui的支持孱弱 467\n20.3.3 文件删除不可撤销 468\n20.3.4 unix假定文件系统是静态的 469\n20.3.5 作业控制设计拙劣 469\n20.3.6 unix api 没有使用异常 470\n20.3.7 ioctl(2)和fcntl(2)是个尴尬 471\n20.3.8 unix安全模型可能太过原始 471\n20.3.9 unix名字种类太多 472\n20.3.10 文件系统可能有害论 472\n20.3.11 朝向全局互联网地址空间 472\n20.4 unix的环境问题 473\n20.5 unix文化中的问题 475\n20.6 信任的理由 477\n附录a 缩写词表 479\n附录b 参考文献 483\n附录c 贡献者 495\n附录d 无根的根：无名师的unix心传 499\ncolophon 510\n索引 511","pages":"530","images":{"small":"https://img3.doubanio.com\/spic\/s6476712.jpg","large":"https://img3.doubanio.com\/lpic\/s6476712.jpg","medium":"https://img3.doubanio.com\/mpic\/s6476712.jpg"},"alt":"https:\/\/book.douban.com\/subject\/5387401\/","id":"5387401","publisher":"电子工业出版社","isbn10":"7121123290","isbn13":"9787121123290","title":"UNIX编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/5387401","alt_title":"The Art of UNIX Programming","author_intro":"《The Art of UNIX Programming》，简称TAOUP，作者Eric S. Raymond，简称ESR。这大概是计算机类书籍中很少见的一本课外读物。TCP\/IP编程之类典型Unix编程书中讲到的东西在这本书里面找不到，所以书里讲到的当然就是别的书里找不到的东西。读者也许需要有相当的Unix背景、或者长期钻研某个专题，才能体会到作者的弦外之音。ESR作为老牌黑客信手拈来的典故，如果不是在Unix里面长期浸淫，大概很难有所共鸣，所以把这当作Unix的一部坊间史话倒也合适。","summary":"本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。","series":{"id":"6628","title":"传世经典书丛"},"price":"69.00元"},{"rating":{"max":10,"numRaters":205,"average":"8.6","min":0},"subtitle":"","author":["（美）Norman Matloff"],"pubdate":"2013-5","tags":[{"count":236,"name":"R","title":"R"},{"count":177,"name":"数据分析","title":"数据分析"},{"count":120,"name":"R语言","title":"R语言"},{"count":92,"name":"编程","title":"编程"},{"count":65,"name":"数据挖掘","title":"数据挖掘"},{"count":34,"name":"程序设计","title":"程序设计"},{"count":31,"name":"计算机","title":"计算机"},{"count":25,"name":"统计","title":"统计"}],"origin_title":"The Art of R Programming: A Tour of Statistical Software Design","image":"https://img1.doubanio.com\/mpic\/s26540607.jpg","binding":"平装","translator":["陈堰平","邱怡轩","潘岚锋 等"],"catalog":"译者序\n前　言\n致　谢\n第1章　快速入门\n1.1　怎样运行R\n1.1.1　交互模式\n1.1.2　批处理模式\n1.2　第一个R会话\n1.3　函数入门\n1.3.1　变量的作用域\n1.3.2　默认参数\n1.4　R语言中一些重要的数据结构\n1.4.1　向量，R语言中的战斗机\n1.4.2　字符串\n1.4.3　矩阵\n1.4.4　列表\n1.4.5　数据框\n1.4.6　类\n1.5　扩展案例：考试成绩的回归分析\n1.6　启动和关闭R\n1.7　获取帮助\n1.7.1　help()函数\n1.7.2　example()函数\n1.7.3　如果你不太清楚要查找什么\n1.7.4　其他主题的帮助\n1.7.5　批处理模式的帮助\n1.7.6　互联网资源\n第2章　向量\n2.1　标量、向量、数组与矩阵\n2.1.1　添加或删除向量元素\n2.1.2　获取向量长度\n2.1.3　作为向量的矩阵和数组\n2.2　声明\n2.3　循环补齐\n2.4　常用的向量运算\n2.4.1　向量运算和逻辑运算\n2.4.2　向量索引\n2.4.3　用：运算符创建向量\n2.4.4　使用seq()创建向量\n2.4.5　使用rep()重复向量常数\n2.5　使用all()和any()\n2.5.1　扩展案例：寻找连续出现1的游程\n2.5.2　扩展案例：预测离散值时间序列\n2.6　向量化运算符\n2.6.1　向量输入，向量输出\n2.6.2　向量输入，矩阵输出\n2.7　NA与NULL值\n2.7.1　NA的使用\n2.7.2　NULL的使用\n2.8　筛选\n2.8.1　生成筛选索引\n2.8.2　使用subset()函数筛选\n2.8.3　选择函数which()\n2.9　向量化的ifelse()函数\n2.9.1　扩展案例：度量相关性\n2.9.2　扩展案例：对鲍鱼数据集重新编码\n2.10　测试向量相等\n2.11　向量元素的名称\n2.12　关于c()的更多内容\n第3章　矩阵和数组\n3.1　创建矩阵\n3.2　一般矩阵运算\n3.2.1　线性代数运算\n3.2.2　矩阵索引\n3.2.3　扩展案例：图像操作\n3.2.4　矩阵元素筛选\n3.2.5　扩展案例：生成协方差矩阵\n3.3　对矩阵的行和列调用函数\n3.3.1　使用apply()函数\n3.3.2　扩展案例：寻找异常值\n3.4　增加或删除矩阵的行或列\n3.4.1　改变矩阵的大小\n3.4.2　扩展案例：找到图中距离最近的一对端点\n3.5　向量与矩阵的差异\n3.6　避免意外降维\n3.7　矩阵的行和列的命名问题\n3.8　高维数组\n第4章　列表\n4.1　创建列表\n4.2　列表的常规操作\n4.2.1　列表索引\n4.2.2　增加或删除列表元素\n4.2.3　获取列表长度\n4.2.4　扩展案例：文本词汇索引\n4.3　访问列表元素和值\n4.4　在列表上使用apply系列函数\n4.4.1　lapply()和sapply()的使用\n4.4.2　扩展案例：文本词汇索引（续）\n4.4.3　扩展案例：鲍鱼数据\n4.5　递归型列表\n第5章　数据框\n5.1　创建数据框\n5.1.1　访问数据框\n5.1.2　扩展案例：考试成绩的回归分析（续）\n5.2　其他矩阵式操作\n5.2.1　提取子数据框\n5.2.2　缺失值的处理\n5.2.3　使用rbind()和cbind()等函数\n5.2.4　使用apply()\n5.2.5　扩展案例：工资研究\n5.3　合并数据框\n5.4　应用于数据框的函数\n5.4.1　在数据框上应用lapply()和sapply()函数\n5.4.2　扩展案例：应用Logistic模型\n5.4.3　扩展案例：学习中文方言的辅助工具\n第6章　因子和表\n6.1　因子与水平\n6.2　因子的常用函数\n6.2.1　tapply函数\n6.2.2　split()函数\n6.2.3　by()函数\n6.3　表的操作\n6.3.1　表中有关矩阵和类似数组的操作\n6.3.2　扩展案例： 提取子表\n6.3.3　扩展案例：在表中寻找频数最大的单元格\n6.4　其他与因子和表有关的函数\n6.4.1　aggregate()函数\n6.4.2　cut()函数\n第7章　R语言编程结构\n7.1　控制语句\n7.1.1　循环\n7.1.2　对非向量集合的循环\n7.1.3　if-else结构\n7.2　算术和逻辑运算符及数值\n7.3　参数的默认值\n7.4　返回值\n7.4.1　决定是否显式调用return ()\n7.4.2　返回复杂对象\n7.5　函数都是对象\n7.6　环境和变量作用域的问题\n7.6.1　顶层环境\n7.6.2　变量作用域的层次\n7.6.3　关于ls()的进一步讨论\n7.6.4　函数（几乎）没有副作用\n7.6.5　扩展案例：显示调用框的函数\n7.7　R语言中没有指针\n7.8　向上级层次进行写操作\n7.8.1　利用超赋值运算符对非局部变量进行写操作\n7.8.2　用assign()函数对非局部变量进行写操作\n7.8.3　扩展案例：用R语言实现离散事件仿真\n7.8.4　什么时候使用全局变量\n7.8.5　闭包\n7.9　递归\n7.9.1　Quicksort的具体实现\n7.9.2　拓展举例：二叉查找树\n7.10　置换函数\n7.10.1　什么是置换函数\n7.10.2　扩展案例：可记录元素修改次数的向量类\n7.11　写函数代码的工具\n7.11.1　文本编辑器和集成开发环境\n7.11.2　edit()函数\n7.12　创建自己的二元运算符\n7.13　匿名函数\n第8章　数学运算与模拟\n8.1　数学函数\n8.1.1　扩展例子：计算概率\n8.1.2　累积和与累积乘积\n8.1.3　最小值和最大值\n8.1.4　微积分\n8.2　统计分布函数\n8.3　排序\n8.4　向量和矩阵的线性代数运算\n8.4.1　扩展示例：向量叉积\n8.4.2　扩展示例：确定马尔科夫链的平稳分布\n8.5　集合运算\n8.6　用R做模拟\n8.6.1　内置的随机变量发生器\n8.6.2　重复运行时获得相同的随机数流\n8.6.3　扩展案例：组合的模拟\n第9章　面向对象的编程\n9.1　S3类\n9.1.1　S3泛型函数\n9.1.2　实例：线性模型函数lm()中的OOP\n9.1.3　寻找泛型函数的实现方法\n9.1.4　编写S3类\n9.1.5　使用继承\n9.1.6　扩展示例：用于存储上三角矩阵的类\n9.1.7　扩展示例：多项式回归程序\n9.2　S4类\n9.2.1　编写S4类\n9.2.2　在S4类上实现泛型函数\n9.3　S3类和S4类的对比\n9.4　对象的管理\n9.4.1　用ls()函数列出所有对象\n9.4.2　用rm()函数删除特定对象\n9.4.3　用save()函数保存对象集合\n9.4.4　查看对象内部结构\n9.4.5　exists()函数\n第10章　输入与输出\n10.1　连接键盘与显示器\n10.1.1　使用scan()函数\n10.1.2　使用readline()函数\n10.1.3　输出到显示器\n10.2　读写文件\n10.2.1　从文件中读取数据框或矩阵\n10.2.2　读取文本文件\n10.2.3　连接的介绍\n10.2.4　扩展案例：读取PUMS普查数据\n10.2.5　通过URL在远程计算机上访问文件\n10.2.6　写文件\n10.2.7　获取文件和目录信息\n10.2.8　扩展案例：多个文件内容的和\n10.3　访问互联网\n10.3.1　TCP\/IP概述\n10.3.2　R中的socket\n10.3.3　扩展案例：实现R的并行计算\n第11章　字符串操作\n11.1　字符串操作函数概述\n11.1.1　grep()\n11.1.2　nchar()\n11.1.3　paste()\n11.1.4　sprintf()\n11.1.5　substr()\n11.1.6　strsplit()\n11.1.7　regexpr()\n11.1.8　gregexpr()\n11.2　正则表达式\n11.2.1　扩展案例：检测文件名的后缀\n11.2.2　扩展案例：生成文件名\n11.3　在调试工具edtdbg中使用字符串工具\n第12章　绘图\n12.1　创建图形\n12.1.1　基础图形系统的核心：plot()函数\n12.1.2　添加线条：abline()函数\n12.1.3　在保持现有图形的基础上新增一个绘图窗口\n12.1.4　扩展案例：在一张图中绘制两条密度曲线\n12.1.5　扩展案例：进一步考察多项式回归\n12.1.6　添加点：points()函数\n12.1.7　添加图例：legend()函数\n12.1.8　添加文字：text()函数\n12.1.9　精确定位：locator()函数\n12.1.10　保存图形\n12.2　定制图形\n12.2.1　改变字符大小：cex选项\n12.2.2　改变坐标轴的范围：xlim和ylim选项\n12.2.3　添加多边形：polygon()函数\n12.2.4　平滑散点：lowess()和loess()函数\n12.2.5　绘制具有显式表达式的函数\n12.2.6　扩展案例：放大曲线的一部分\n12.3　将图形保存到文件\n12.3.1　R图形设备\n12.3.2　保存已显示的图形\n12.3.3　关闭R图形设备\n12.4　创建三维图形\n第13章　调试\n13.1　调试的基本原则\n13.1.1　调试的本质：确认原则\n13.1.2　从小处着手\n13.1.3　模块化的、自顶向下的调试风格\n13.1.4　反漏洞\n13.2　为什么要使用调试工具\n13.3　使用R的调试工具\n13.3.1　利用debug()和browser()函数进行逐步调试\n13.3.2　使用浏览器命令\n13.3.3　设置断点\n13.3.4　使用trace()函数进行追踪\n13.3.5　使用traceback()和debugger()函数对崩溃的程序进行检查\n13.3.6　扩展案例：两个完整的调试会话\n13.4　更方便的调试工具\n13.5　在调试模拟数据的代码时请确保一致性\n13.6　语法和运行时错误\n13.7　在R上运行GDB\n第14章　性能提升：速度和内存\n14.1　编写快速的R代码\n14.2　可怕的for循环\n14.2.1　用向量化提升速度\n14.2.2　扩展案例：在蒙特卡罗模拟中获得更快的速度\n14.2.3　扩展案例：生成幂次矩阵\n14.3　函数式编程和内存问题\n14.3.1　向量赋值问题\n14.3.2　改变时拷贝\n14.3.3　扩展案例：避免内存拷贝\n14.4　利用Rprof()来寻找代码的瓶颈\n14.4.1　利用Rprof()来进行监视\n14.4.2　Rprof()的工作原理\n14.5　字节码编译\n14.6　内存无法装下数据怎么办\n14.6.1　分块\n14.6.2　利用R软件包来进行内存管理\n第15章　R与其他语言的接口\n15.1　编写能被R调用的C\/C++函数\n15.1.1　R与C\/C++交互的预备知识\n15.1.2　例子：提取方阵的次对角线元素\n15.1.3　编译和运行程序\n15.1.4　调试R\/C程序\n15.1.5　扩展案例：预测离散取值的时间序列\n15.2　从Python调用R\n15.2.1　安装RPy\n15.2.2　RPy语法\n第16章　R语言并行计算\n16.1　共同外链问题\n16.2　snow包简介\n16.2.1　运行snow代码\n16.2.2　分析snow代码\n16.2.3　可以获得多少倍的加速\n16.2.4　扩展案例：K均值聚类\n16.3　借助于C\n16.3.1　利用多核机器\n16.3.2　扩展案例：利用OpenMP解决共同外链问题\n16.3.3　运行OpenMP代码\n16.3.4　OpenMP代码分析\n16.3.5　其他OpenMP指令\n16.3.6　GPU编程\n16.4　普遍的性能考虑\n16.4.1　开销的来源\n16.4.2　简单并行程序，以及那些不简单的\n16.4.3　静态和动态任务分配\n16.4.4　软件炼金术：将一般的问题转化为简单并行问题\n16.5　调试R语言并行计算的代码\n附录A　安装R\n附录B　安装和使用包","ebook_url":"https:\/\/read.douban.com\/ebook\/37156518\/","pages":"303","images":{"small":"https://img1.doubanio.com\/spic\/s26540607.jpg","large":"https://img1.doubanio.com\/lpic\/s26540607.jpg","medium":"https://img1.doubanio.com\/mpic\/s26540607.jpg"},"alt":"https:\/\/book.douban.com\/subject\/24699632\/","id":"24699632","publisher":"机械工业出版社","isbn10":"7111423143","isbn13":"9787111423140","title":"R语言编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/24699632","alt_title":"The Art of R Programming: A Tour of Statistical Software Design","author_intro":"Norman Matloff 著名计算机科学家兼统计学家，美国加州大学戴维斯分校计算机科学系教授，曾是该校统计专业的创建者之一，并担任过统计学教授。对并行编程、网络流量、数据挖掘、磁盘系统性能等方面的技术都有深入的研究。乐于分享，撰写了多部广受欢迎的关于软件开发的在线教程，多次为《纽约时报》、《华盛顿邮报》、《福布斯杂志》以及《洛杉矶时报》撰写文章，同时他还是《The Art of Debugging》的作者之一。","summary":"【编辑推荐】\n这本书涵盖了R语言编程的诸多方面，尤其在面向对象编程、程序调试、提升程序运行速度以及并行计算等方面，填补了同类图书的空白。关于程序调试的章节更是作者多年经验的总结。不管是初学者还是有一定编程经验的读者，阅读这本书都会有所收获。\n——统计之都\n【内容简介】\nR语言是世界上最流行的用于数据处理和统计分析的脚本语言。考古学家用它来跟踪古代文明的传播，医药公司用它来探索哪种药物更安全、更有效，精算师用它评估金融风险以保证市场的平稳运行。总之，在大数据时代，统计数据、分析数据都离不开计算机软件的支持，在这方面R语言尤其出色。\n本书将带领你踏上R语言软件开发之旅，从最基本的数据类型和数据结构开始，到闭包、递归和匿名函数等高级主题，由浅入深，讲解细腻，读者完全不需要统计学的知识，甚至不需要编程基础。而书中提到的很多高级编程技巧，都是作者多年编程经验的总结，对有经验的开发者也大有裨益。本书精选了44个扩展案例，这些案例都源自于作者亲身参与过的咨询项目，都是与数据分析相关的，生动展示了R语言在统计学中的高效应用。\n本书核心内容：\n R语言的完整语法以及R语言的编程技巧\n 创建精美图形来展示复杂数据和函数\n 使用并行计算和向量化的方法编写更高效的代码\n 使用R对C\/C++和Python的接口来提高计算速度或增加功能\n 文本分析、图像处理等领域新的R包\n 使用高级调试技巧清除代码里恼人的错误\n 包含许多“扩展案例”，展示完整的、特定用途的函数，并针对同一个问题讨论了不同的设计方案，以便分析高效准确的做法。\n 在恰当的时候介绍R语言与其他语言的差异，给那些了解其他语言的开发人员提供参考。\n【相关图书推荐】\n978-7-111-40700-3 数据挖掘与R语言\n978-7-111-42021-7 R语言经典实例\n978-7-111-41731-6 机器学习：实用案例解析\n978-7-111-32572-7 时间序列分析及应用：R语言（原书第2版）","ebook_price":"25.00","price":"69.00"},{"rating":{"max":10,"numRaters":234,"average":"9.2","min":0},"subtitle":"深入数据库体系结构","author":["Thomas Kyte"],"pubdate":"2006-10","tags":[{"count":247,"name":"oracle","title":"oracle"},{"count":162,"name":"数据库","title":"数据库"},{"count":56,"name":"Database","title":"Database"},{"count":52,"name":"计算机","title":"计算机"},{"count":42,"name":"DBA","title":"DBA"},{"count":31,"name":"数据库编程","title":"数据库编程"},{"count":30,"name":"Oracle","title":"Oracle"},{"count":19,"name":"IT","title":"IT"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s5745592.jpg","binding":"平装","translator":["苏金国","王小振"],"catalog":"第1章　开发成功的Oracle应用\n第2章　体系结构概述\n第3章　文件\n第4章　内存结构\n第5章　Oracle进程\n第6章　锁\n第7章　并发与多版本\n第8章　事务\n第9章　redo与undo\n第10章　数据库表\n第11章　索引\n第12章　数据类型\n第13章　分区\n第14章　并行执行\n第15章　数据加载和卸载\n索引","pages":"737","images":{"small":"https://img3.doubanio.com\/spic\/s5745592.jpg","large":"https://img3.doubanio.com\/lpic\/s5745592.jpg","medium":"https://img3.doubanio.com\/mpic\/s5745592.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1864527\/","id":"1864527","publisher":"人民邮电出版社","isbn10":"711515032X","isbn13":"9787115150325","title":"Oracle 9i & 10g编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/1864527","alt_title":"","author_intro":"","summary":"《Oracle9i&10g编程艺术:深入数据库体系结构》是讲述Oracle数据库公证的权威指南，凝聚了世界顶尖的Oracle专家Thomas Kyte数十年的宝贵经验和大量真的知灼见。书中深入地分析了Oracle数据库体系结构，包括文件、内存结构以及构成Oracle数据库和实例的度层进程，然后讨论了一些重要的数据库主题，如锁定、并发控制、事务、重做和撤销，还解释了这些内重要性。最后，分析了数据库中的物理结构，如表、索引和数据类型，并介绍通过哪些技术能最优地使用这些物理结构。无论你是程序员还是DBA，要创建和管理稳定、高质量的Oracle系统，归根结底都需要理解Oracle数据库的体系结构。","price":"99.00元"},{"rating":{"max":10,"numRaters":84,"average":"9.2","min":0},"subtitle":"深入数据库体系结构","author":["Thomas Kyte"],"pubdate":"2011-1-1","tags":[{"count":153,"name":"oracle","title":"oracle"},{"count":129,"name":"数据库","title":"数据库"},{"count":59,"name":"Database","title":"Database"},{"count":52,"name":"Oracle","title":"Oracle"},{"count":49,"name":"DBA","title":"DBA"},{"count":42,"name":"计算机","title":"计算机"},{"count":21,"name":"11g","title":"11g"},{"count":16,"name":"技术","title":"技术"}],"origin_title":"Expert Oracle Database Architecture: Oracle Database Programming 9i, 10g, and 11g Techniques and Solutions，2E","image":"https://img3.doubanio.com\/mpic\/s4569613.jpg","binding":"平装","translator":["苏金国","王小振"],"catalog":"第1章 开发成功的Oracle应用\t1\n1.1 我的方法\t2\n1.2 黑盒方法\t3\n1.3 开发数据库应用的正确（和不正确）方法\t10\n1.3.1 了解Oracle体系结构\t11\n1.3.2 理解并发控制\t19\n1.3.3 多版本控制\t22\n1.3.4 数据库独立性\t28\n1.3.5 怎么能让应用运行得更快\t42\n1.3.6 DBA与开发人员的关系\t44\n1.4 小结\t45\n第2章 体系结构概述\t46\n2.1 定义数据库和实例\t47\n2.2 SGA和后台进程\t52\n2.3 连接Oracle\t54\n2.3.1 专用服务器\t54\n2.3.2 共享服务器\t56\n2.3.3 TCP\/IP连接的基本原理\t57\n2.4 小结\t59\n第3章 文件\t60\n3.1 参数文件\t61\n3.1.1 什么是参数\t62\n3.1.2 遗留的init.ora参数文件\t65\n3.1.3 服务器参数文件\t67\n3.1.4 参数文件小结\t72\n3.2 跟踪文件\t73\n3.2.1 请求的跟踪文件\t74\n3.2.2 针对内部错误生成的跟踪文件\t78\n3.2.3 跟踪文件小结\t82\n3.3 警告文件\t83\n3.4 数据文件\t85\n3.4.1 简要回顾文件系统机制\t86\n3.4.2 Oracle数据库中的存储层次体系\t87\n3.4.3 字典管理和本地管理的表空间\t90\n3.5 临时文件\t92\n3.6 控制文件\t94\n3.7 重做日志文件\t94\n3.7.1 在线重做日志\t95\n3.7.2 归档重做日志\t97\n3.8 密码文件\t99\n3.9 修改跟踪文件\t102\n3.10 闪回日志\t103\n3.10.1 闪回数据库\t103\n3.10.2 闪回恢复区\t104\n3.11 DMP文件（EXP\/IMP文件）\t104\n3.12 数据泵文件\t105\n3.13 平面文件\t108\n3.14 小结\t109\n第4章 内存结构\t110\n4.1 进程全局区和用户全局区\t110\n4.1.1 手动PGA内存管理\t111\n4.1.2 自动PGA内存管理\t117\n4.1.3 手动和自动内存管理的选择\t127\n4.1.4 PGA和UGA小结\t129\n4.2 系统全局区\t129\n4.2.1 固定SGA\t133\n4.2.2 重做缓冲区\t134\n4.2.3 块缓冲区缓存\t135\n4.2.4 共享池\t141\n4.2.5 大池\t143\n4.2.6 Java池\t144\n4.2.7 流池\t145\n4.2.8 自动SGA内存管理\t145\n4.2.9 自动内存管理\t147\n4.3 小结\t148\n第5章 Oracle进程\t149\n5.1 服务器进程\t149\n5.1.1 专用服务器连接\t150\n5.1.2 共享服务器连接\t152\n5.1.3 数据库常驻连接池\t152\n5.1.4 连接与会话\t153\n5.1.5 专用服务器与共享服务器\t158\n5.1.6 专用\/共享服务器小结\t161\n5.2 后台进程\t162\n5.2.1 中心后台进程\t163\n5.2.2 工具后台进程\t171\n5.3 从属进程\t173\n5.3.1 I\/O从属进程\t173\n5.3.2 Pnnn：并行查询执行服务器\t174\n5.4 小结\t175\n第6章 锁和闩\t176\n6.1 什么是锁\t176\n6.2 锁定问题\t179\n6.2.1 丢失更新\t179\n6.2.2 悲观锁定\t180\n6.2.3 乐观锁定\t182\n6.2.4 乐观锁定还是悲观锁定\t188\n6.2.5 阻塞\t188\n6.2.6 死锁\t191\n6.2.7 锁升级\t195\n6.3 锁类型\t195\n6.3.1 DML锁\t196\n6.3.2 DDL锁\t204\n6.3.3 闩\t209\n6.3.4 手动锁定和用户定义锁\t217\n6.4 小结\t218\n第7章 并发与多版本控制\t219\n7.1 什么是并发控制\t219\n7.2 事务隔离级别\t220\n7.2.1 READ UNCOMMITTED\t221\n7.2.2 READ COMMITTED\t223\n7.2.3 REPEATABLE READ\t224\n7.2.4 SERIALIZABLE\t226\n7.2.5 READ ONLY\t228\n7.3 多版本控制读一致性的含义\t229\n7.3.1 一种会失败的常用数据仓库技术\t229\n7.3.2 解释热表上超出期望的I\/O\t230\n7.4 写一致性\t233\n7.4.1 一致读和当前读\t233\n7.4.2 查看重启动\t235\n7.4.3 为什么重启动对我们很重要\t238\n7.5 小结\t239\n第8章 事务\t240\n8.1 事务控制语句\t240\n8.2 原子性\t242\n8.2.1 语句级原子性\t242\n8.2.2 过程级原子性\t244\n8.2.3 事务级原子性\t247\n8.2.4 DDL与原子性\t247\n8.3 持久性\t247\n8.3.1 COMMIT的WRITE扩展\t248\n8.3.2 非分布式PL\/SQL代码块中的COMMIT\t249\n8.4 完整性约束和事务\t250\n8.4.1 IMMEDIATE约束\t251\n8.4.2 DEFERRABLE约束和级联更新\t251\n8.5 不好的事务习惯\t255\n8.5.1 在循环中提交\t255\n8.5.2 使用自动提交\t261\n8.6 分布式事务\t261\n8.7 自治事务\t263\n8.7.1 自治事务如何工作\t264\n8.7.2 何时使用自治事务\t265\n8.8 小结\t268\n第9章 redo与undo\t269\n9.1 什么是redo\t269\n9.2 什么是undo\t270\n9.3 redo和undo如何协作\t273\n9.4 提交和回滚处理\t277\n9.4.1 COMMIT做什么\t277\n9.4.2 ROLLBACK做什么\t283\n9.5 分析redo\t284\n9.5.1 测量redo\t284\n9.5.2 能关掉重做日志生成程序吗\t286\n9.5.3 为什么不能分配一个新日志\t289\n9.5.4 块清除\t291\n9.5.5 日志竞争\t294\n9.5.6 临时表和redo\/undo\t296\n9.6 分析undo\t299\n9.6.1 什么操作会生成最多和最少的undo\t299\n9.6.2 ORA-01555: snapshot too old 错误\t301\n9.7 小结\t310\n第10章 数据库表\t311\n10.1 表类型\t311\n10.2 术语\t313\n10.2.1 段\t313\n10.2.2 段空间管理\t315\n10.2.3 高水位线\t316\n10.2.4 FREELIST\t317\n10.2.5 PCTFREE和PCTUSED\t320\n10.2.6 LOGGING和NOLOGGING\t323\n10.2.7 INITRANS和MAXTRANS\t324\n10.3 堆组织表\t324\n10.4 索引组织表\t327\n10.5 索引聚簇表\t340\n10.6 散列聚簇表\t347\n10.7 有序散列聚簇表\t355\n10.8 嵌套表\t357\n10.8.1 嵌套表语法\t358\n10.8.2 嵌套表存储\t364\n10.8.3 嵌套表小结\t367\n10.9 临时表\t368\n10.10 对象表\t374\n10.11 小结\t380\n第11章 索引\t382\n11.1 Oracle索引概述\t382\n11.2 B*树索引\t384\n11.2.1 索引键压缩\t386\n11.2.2 反向键索引\t389\n11.2.3 降序索引\t394\n11.2.4 什么情况下应该使用B*树索引\t396\n11.2.5  B*树小结\t405\n11.3 位图索引\t406\n11.3.1 什么情况下应该使用位图索引\t407\n11.3.2 位图联结索引\t410\n11.3.3 位图索引小结\t413\n11.4 基于函数的索引\t413\n11.4.1 重要的实现细节\t413\n11.4.2 一个简单的基于函数的索引例子\t414\n11.4.3 只对部分行建立索引\t422\n11.4.4 实现有选择的唯一性\t424\n11.4.5 关于ORA-01743的警告\t424\n11.4.6 基于函数的索引小结\t425\n11.5 应用域索引\t425\n11.6 关于索引的常见问题和神话\t426\n11.6.1 视图能使用索引吗\t427\n11.6.2 Null和索引能协作吗\t427\n11.6.3 外键是否应该加索引\t429\n11.6.4 为什么没有使用我的索引\t430\n11.6.5 神话：索引中从不重用空间\t435\n11.6.6 神话：最有差别的元素应该在最前面\t438\n11.7 小结\t441\n第12章 数据类型\t442\n12.1 Oracle数据类型概述\t442\n12.2 字符和二进制串类型\t444\n12.2.1 NLS概述\t445\n12.2.2 字符串\t448\n12.3 二进制串：RAW类型\t453\n12.4 数值类型\t455\n12.4.1 NUMBER类型的语法和用法\t457\n12.4.2 BINARY_FLOAT\/BINARY_DOUBLE类型的语法和用法\t460\n12.4.3 非固有数值类型\t461\n12.4.4 性能考虑\t461\n12.5 LONG类型\t463\n12.5.1 LONG和LONG RAW类型的限制\t463\n12.5.2 处理遗留的LONG类型\t464\n12.6 DATE、TIMESTAMP和INTERVAL类型\t469\n12.6.1 格式\t469\n12.6.2 DATE类型\t470\n12.6.3 TIMESTAMP类型\t475\n12.6.4 INTERVAL类型\t482\n12.7 LOB 类型\t484\n12.7.1 内部LOB\t485\n12.7.2 BFILE\t495\n12.8 ROWID\/UROWID类型\t497\n12.9 小结\t497\n第13章 分区\t499\n13.1 分区概述\t499\n13.1.1 提高可用性\t500\n13.1.2 减少管理负担\t502\n13.1.3 改善语句性能\t505\n13.2 表分区机制\t507\n13.2.1 区间分区\t508\n13.2.2 散列分区\t510\n13.2.3 列表分区\t513\n13.2.4 间隔分区\t515\n13.2.5 引用分区\t520\n13.2.6 组合分区\t524\n13.2.7 行移动\t526\n13.2.8 表分区机制小结\t528\n13.3 索引分区\t529\n13.3.1 局部索引与全局索引\t530\n13.3.2 局部索引\t530\n13.3.3 全局索引\t535\n13.4 再论分区和性能\t547\n13.5 审计和段空间压缩\t552\n13.6 小结\t553\n第14章 并行执行\t555\n14.1 何时使用并行执行\t556\n14.2 Oracle Exadata\t558\n14.3 并行查询\t558\n14.4 并行DML\t564\n14.5 并行DDL\t566\n14.5.1 并行DDL和使用外部表的数据加载\t567\n14.5.2 并行DDL和区段截断\t568\n14.6 并行恢复\t576\n14.7 过程并行化\t577\n14.7.1 并行管道函数\t578\n14.7.2 DIY并行化\t580\n14.7.3 老式DIY并行化\t583\n14.8 小结\t587\n第15章 数据加载和卸载\t588\n15.1 SQLLDR\t588\n15.1.1 用SQLLDR加载数据的常见问题\t592\n15.1.2 SQLLDR警告\t613\n15.1.3 SQLLDR小结\t614\n15.2 外部表\t614\n15.2.1 建立外部表\t615\n15.2.2 处理错误\t619\n15.2.3 使用外部表加载不同的文件\t622\n15.2.4 多用户问题\t623\n15.2.5 外部表小结\t624\n15.3 平面文件卸载\t624\n15.4 数据泵卸载\t631\n15.5 小结\t633\n第16章 数据加密\t634\n16.1 加密类型\t634\n16.1.1 动态数据\t634\n16.1.2 静态数据\t635\n16.1.3 手动应用加密\t638\n16.1.4 Oracle钱夹\t639\n16.1.5 透明列级加密\t641\n16.1.6 透明表空间加密\t644\n16.2 加密不是访问控制\t646\n16.3 实现手动应用加密\t647\n16.3.1 避免使用手动方法的原因\t648\n16.3.2 手动方法的性能影响\t648\n16.3.3 何时使用手动方法\t652\n16.4 实现列级加密\t652\n16.4.1 如何使用列级加密\t653\n16.4.2 列级加密的数据存储\t653\n16.4.3 测量列级加密的性能影响\t657\n16.4.4 影响大小\t657\n16.4.5 列级加密的限制\t662\n16.5 实现表空间加密\t663\n16.5.1 如何使用表空间加密\t663\n16.5.2 表空间加密的数据存储\t664\n16.5.3 测量表空间加密的性能影响\t665\n16.6 决定采用哪种加密技术\t670\n16.7 小结\t671\n索引\t672\n","pages":"706","images":{"small":"https://img3.doubanio.com\/spic\/s4569613.jpg","large":"https://img3.doubanio.com\/lpic\/s4569613.jpg","medium":"https://img3.doubanio.com\/mpic\/s4569613.jpg"},"alt":"https:\/\/book.douban.com\/subject\/5402711\/","id":"5402711","publisher":"人民邮电出版社","isbn10":"7115244855","isbn13":"9787115244857","title":"Oracle Database 9i\/10g\/11g编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/5402711","alt_title":"Expert Oracle Database Architecture: Oracle Database Programming 9i, 10g, and 11g Techniques and Solutions，2E","author_intro":"Thomas Kyte  Oracle公司核心技术集团副总裁。从5.1.1c版本开始使用Oracle，自7.0.9版本发布就一直任职于Oracle公司，帮助Oracle数据库用户设计和构建系统，或者对系统进行重构和调优。此前曾是一位系统集成师，主要为美国军方和政府部门的客户构建大规模的异构数据库和应用。长期主持Oracle Magazine “Ask Tom”专栏，热心回答困扰全世界Oracle开发人员和DBA的各种问题。除本书外，还著有广受好评的《Oracle专家高级编程》和《Oracle高效设计》。","summary":"无论你是开发人员还是DBA，要创建和管理稳定、高质量的Oracle系统，归根结底都需要理解Oracle数据库的体系结构。\n本书是公认的Oracle数据库权威指南，凝聚了世界顶尖的Oracle专家Thomas Kyte数十年的宝贵经验和真知灼见。书中深入分析了Oracle数据库体系结构，包括文件、内存结构以及构成Oracle数据库和实例的底层进程，利用具体示例讨论了一些重要的数据库主题，如锁定、并发控制、事务等。同时分析了数据库中的物理结构，如表、索引和数据类型，并介绍采用哪些技术能最优地使用这些物理结构。本书在上一版的基础上做了大量增补，以涵盖11g最受关注的多项特性，尤其针对数据加密的途径进行了详细的阐释。","price":"109.00元"},{"rating":{"max":10,"numRaters":60,"average":"9.7","min":0},"subtitle":"","author":["雷蒙德"],"pubdate":"2006-8","tags":[{"count":72,"name":"UNIX","title":"UNIX"},{"count":29,"name":"编程","title":"编程"},{"count":21,"name":"计算机","title":"计算机"},{"count":18,"name":"Programming","title":"Programming"},{"count":13,"name":"经典","title":"经典"},{"count":11,"name":"文化","title":"文化"},{"count":10,"name":"Linux","title":"Linux"},{"count":9,"name":"Linux\/Unix","title":"Linux\/Unix"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s2787625.jpg","binding":"平装","translator":[],"catalog":"","pages":"525","images":{"small":"https://img3.doubanio.com\/spic\/s2787625.jpg","large":"https://img3.doubanio.com\/lpic\/s2787625.jpg","medium":"https://img3.doubanio.com\/mpic\/s2787625.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1909192\/","id":"1909192","publisher":"人民邮电出版社","isbn10":"7115149860","isbn13":"9787115149862","title":"UNIX编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/1909192","alt_title":"","author_intro":"","summary":"《UNIX编程艺术》(英文版)内容涉及领域文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧，是UNIX领域中一本不朽的经典名著。","price":"52.0"},{"rating":{"max":10,"numRaters":31,"average":"9.6","min":0},"subtitle":"","author":["[美] Eric S. Raymond"],"pubdate":"2012-8","tags":[{"count":24,"name":"Unix","title":"Unix"},{"count":23,"name":"编程","title":"编程"},{"count":17,"name":"计算机","title":"计算机"},{"count":16,"name":"程序设计","title":"程序设计"},{"count":10,"name":"UNIX","title":"UNIX"},{"count":8,"name":"Linux\/Unix","title":"Linux\/Unix"},{"count":7,"name":"计算机科学","title":"计算机科学"},{"count":5,"name":"软件开发","title":"软件开发"}],"origin_title":"The Art of UNIX Programming","image":"https://img1.doubanio.com\/mpic\/s11345267.jpg","binding":"平装","translator":["姜宏","何源","蔡晓骏"],"catalog":"序\nPartIⅠ1\n第1章 哲学3\n1.1 文化？什么文化3\n1.2 Unix的生命力4\n1.3 反对学习Unix文化的理由5\n1.4 Unix之失6\n1.5 Unix之得7\n1.5.1 开源软件7\n1.5.2 跨平台可移植性和开放标准8\n1.5.3 Internet和万维网8\n1.5.4 开源社区9\n1.5.5 从头到脚的灵活性9\n1.5.6 UnixHack之趣10\n1.5.7 Unix的经验别处也可适用11\n1.6 Unix哲学基础11\n1.6.1 模块原则：使用简洁的接口拼合简单的部件14\n1.6.2 清晰原则：清晰胜于机巧14\n1.6.3 组合原则：设计时考虑拼接组合15\n1.6.4 分离原则：策略同机制分离，接口同引擎分离16\n1.6.5 简洁原则：设计要简洁，复杂度能低则低17\n1.6.6 吝啬原则：除非确无它法，不要编写庞大的程序18\n1.6.7 透明性原则：设计要可见，以便审查和调试18\n1.6.8 健壮原则：健壮源于透明与简洁18\n1.6.9 表示原则：把知识叠入数据以求逻辑质朴而健壮19\n1.6.10 通俗原则：接口设计避免标新立异20\n1.6.11 缄默原则：如果一个程序没什么好说的，就保持沉默20\n1.6.12 补救原则：出现异常时，马上退出并给出足量错误信息21\n1.6.13 经济原则：宁花机器一分，不花程序员一秒22\n1.6.14 生成原则：避免手工hack，尽量编写程序去生成程序22\n1.6.15 优化原则：雕琢前先得有原型，跑之前先学会走23\n1.6.16 多样原则：决不相信所谓“不二法门”的断言24\n1.6.17 扩展原则：设计着眼未来，未来总比预想快24\n1.7 Unix哲学之一言以蔽之25\n1.8 应用Unix哲学26\n1.9 态度也要紧26\n第2章 历史——双流记29\n2.1 Unix的起源及历史，1969－199529\n2.1.1 创世纪：1969－197130\n2.1.2 出埃及记：1971－198032\n2.1.3 TCP\/IP和Unix内战：1980－199035\n2.1.4 反击帝国：1991－199541\n2.2 黑客的起源和历史：1961－199543\n2.2.1 游戏在校园的林间：1961－198044\n2.2.2 互联网大融合与自由软件运动：1981－199145\n2.2.3 Linux和实用主义者的应对：1991－199848\n2.3 开源运动：1998年及之后49\n2.4 Unix的历史教训51\n第3章 对比：Unix哲学同其他哲学的比较53\n3.1 操作系统的风格元素53\n3.1.1 什么是操作系统的统一性理念54\n3.1.2 多任务能力54\n3.1.3 协作进程55\n3.1.4 内部边界57\n3.1.5 文件属性和记录结构57\n3.1.6 二进制文件格式58\n3.1.7 首选用户界面风格58\n3.1.8 目标受众59\n3.1.9 开发的门坎60\n3.2 操作系统的比较61\n3.2.1 VMS61\n3.2.2 MacOS64\n3.2.3 OS\/265\n3.2.4 WindowsNT68\n3.2.5 BeOS71\n3.2.6 MVS72\n3.2.7 VM\/CMS74\n3.2.8 Linux76\n3.3 种什么籽，得什么果78\nPartⅡ81\n第4章 模块性：保持清晰，保持简洁83\n4.1 封装和最佳模块大小85\n4.2 紧凑性和正交性87\n4.2.1 紧凑性87\n4.2.2 正交性89\n4.2.3 SPOT原则91\n4.2.4 紧凑性和强单一中心92\n4.2.5 分离的价值94\n4.3 软件是多层的95\n4.3.1 自顶向下和自底向上95\n4.3.2 胶合层97\n4.3.3 实例分析：被视为薄胶合层的C语言98\n4.4 程序库99\n4.4.1 实例分析：GIMP插件100\n4.5 Unix和面向对象语言101\n4.6 模块式编码103\n第5章 文本化：好协议产生好实践105\n5.1 文本化的重要性107\n5.1.1 实例分析：Unix口令文件格式109\n5.1.2 实例分析：newsrc格式110\n5.1.3 实例分析：PNG图形文件格式111\n5.2 数据文件元格式112\n5.2.1 DSV风格113\n5.2.2 RFC822格式114\n5.2.3 Cookie—Jar格式115\n5.2.4 Record—Jar格式116\n5.2.5 XML117\n5.2.6 WindowsINI格式119\n5.2.7 Unix文本文件格式的约定120\n5.2.8 文件压缩的利弊122\n5.3 应用协议设计123\n5.3.1 实例分析：SMTP，一个简单的套接字协议124\n5.3.2 实例分析：POP3，邮局协议124\n5.3.3 实例分析：IMAP，互联网消息访问协议126\n5.4 应用协议元格式127\n5.4.1 经典的互联网应用元协议127\n5.4.2 作为通用应用协议的HTTP128\n5.4.3 BEEP：块可扩展交换协议130\n5.4.4 XML—RPC，SOAP和Jabber131\n第6章 透明性：来点儿光133\n6.1 研究实例135\n6.1.1 实例分析：audacity135\n6.1.2 实例分析：fetchmail的–v选项136\n6.1.3 实例分析：GCC139\n6.1.4 实例分析：kmail140\n6.1.5 实例分析：SNG142\n6.1.6 实例分析：Terminfo数据库144\n6.1.7 实例分析：Freeciv数据文件146\n6.2 为透明性和可显性而设计148\n6.2.1 透明性之禅149\n6.2.2 为透明性和可显性而编码150\n6.2.3 透明性和避免过度保护151\n6.2.4 透明性和可编辑的表现形式152\n6.2.5 透明性、故障诊断和故障恢复153\n6.3 为可维护性而设计154\n第7章 多道程序设计：分离进程为独立的功能157\n7.1 从性能调整中分离复杂度控制159\n7.2 UnixIPC方法的分类160\n7.2.1 把任务转给专门程序160\n7.2.2 管道、重定向和过滤器161\n7.2.3 包装器166\n7.2.4 安全性包装器和Bernstein链167\n7.2.5 从进程168\n7.2.6 对等进程间通信169\n7.3 要避免的问题和方法176\n7.3.1 废弃的UnixIPC方法176\n7.3.2 远程过程调用178\n7.3.3 线程——恐吓或威胁180\n7.4 在设计层次上的进程划分181\n第8章 微型语言：寻找歌唱的乐符183\n8.1 理解语言分类法185\n8.2 应用微型语言187\n8.2.1 案例分析：sng187\n8.2.2 案例分析：正则表达式188\n8.2.3 案例分析：Glade191\n8.2.4 案例分析：m4193\n8.2.5 案例分析：XSLT194\n8.2.6 案例分析：TheDocumenter's work bench Tools195\n8.2.7 案例分析：fetchmail的运行控制语法199\n8.2.8 案例分析：awk200\n8.2.9 案例分析：PostScript202\n8.2.10 案例分析：bc和dc203\n8.2.11 案例分析：EmacsLisp205\n8.2.12 案例分析：JavaScript205\n8.3 设计微型语言206\n8.3.1 选择正确的复杂度207\n8.3.2 扩展和嵌入语言209\n8.3.3 编写自定义语法210\n8.3.4 宏—慎用210\n8.3.5 语言还是应用协议212\n第9章 生成：提升规格说明的层次215\n9.1 数据驱动编程216\n9.1.1 实例分析：ascii217\n9.1.2 实例分析：统计学的垃圾邮件统计218\n9.1.3 实例分析：fetchmailconf中的元类改动219\n9.2 专用代码的生成225\n9.2.1 实例分析：生成ascii显示的代码225\n9.2.2 实例分析：为列表生成HTML代码227\n第10章 配置：迈出正确的第一步231\n10.1 什么应是可配置的231\n10.2 配置在哪里233\n10.3 运行控制文件234\n10.3.1 实例分析：.Netrc文件236\n10.3.2 到其它操作系统的可移植性238\n10.4 环境变量238\n10.4.1 系统环境变量238\n10.4.2 用户环境变量240\n10.4.3 何时使用环境变量240\n10.4.4 到其它操作系统的可移植性242\n10.5 命令行选项242\n10.5.1 从–a到–z的命令行选项243\n10.5.2 到其它操作系统的可移植性248\n10.6 如何挑选方法248\n10.6.1 实例分析：fetchmail249\n10.6.2 实例分析：XFree86服务器251\n10.7 论打破规则252\n第11章 接口：Unix环境下的用户接口设计模式253\n11.1 最小立异原则的应用254\n11.2 Unix接口设计的历史256\n11.3 接口设计评估257\n11.4 CLI和可视接口之间的权衡259\n11.4.1 实例分析：编写计算器程序的两种方式262\n11.5 透明度、表现力和可配置性264\n11.6 Unix接口设计模式266\n11.6.1 过滤器模式266\n11.6.2 Cantrip模式268\n11.6.3 源模式268\n11.6.4 接收器模式269\n11.6.5 编译器模式269\n11.6.6 ed模式270\n11.6.7 Roguelike模式270\n11.6.8 “引擎和接口分离”模式273\n11.6.9 CLI服务器模式278\n11.6.10 基于语言的接口模式279\n11.7 应用Unix接口设计模式280\n11.7.1多价程序模式\n11.8 网页浏览器作为通用前端281\n11.9 沉默是金284\n第12章 优化287\n12.1 什么也别做，就站在那儿287\n12.2 先估量，后优化288\n12.3 非定域性之害290\n12.4 吞吐量和延迟291\n12.4.1 批操作292\n12.4.2 重叠操作293\n12.4.3 缓存操作结果293\n第13章 复杂度：尽可能简单，但别简过了头295\n13.1 谈谈复杂度296\n13.1.1 复杂度的三个来源296\n13.1.2 接口复杂度和实现复杂度的折中298\n13.1.3 必然的、可能的和偶然的复杂度299\n13.1.4 映射复杂度300\n13.1.5 当简洁性不能胜任302\n13.2 五个编辑器的故事302\n13.2.1 ed304\n13.2.2 vi305\n13.2.3 Sam306\n13.2.4 Emacs307\n13.2.5 Wily308\n13.3 编辑器的适当规模309\n13.3.1 甄别复杂度问题309\n13.3.2 折衷无用312\n13.3.3 Emacs是个反Unix传统的论据吗314\n13.4 软件的适度规模316\nPartⅢ319\n第14章 语言：C还是非C321\n14.1 Unix下语言的丰饶321\n14.2 为什么不是C323\n14.3 解释型语言和混合策略325\n14.4 语言评估325\n14.4.1 C326\n14.4.2 C++327\n14.4.3 Shell330\n14.4.4 Perl332\n14.4.5 Tcl334\n14.4.6 Python336\n14.4.7 Java339\n14.4.8 EmacsLisp342\n14.5 未来趋势344\n14.6 选择X工具包346\n第15章 工具：开发的战术349\n15.1 开发者友好的操作系统349\n15.2 编辑器选择350\n15.2.1 了解vi351\n15.2.2 了解Emacs351\n15.2.3 非虔诚的选择：两者兼用352\n15.3 专用代码生成器352\n15.3.1 yacc和lex353\n15.3.2 实例分析：fetchmailrc的语法356\n15.3.3 实例分析：Glade356\n15.4 make：自动化编译357\n15.4.1 make的基本理论357\n15.4.2 非C\/C++开发中的make359\n15.4.3 通用生成目标359\n15.4.4 生成Makefile362\n15.5 版本控制系统364\n15.5.1 为什么需要版本控制364\n15.5.2 手工版本控制365\n15.5.3 自动化的版本控制366\n15.5.4 Unix的版本控制工具367\n15.6 运行期调试369\n15.7 性能分析370\n15.8 使用Emacs整合工具370\n15.8.1 Emacs和make371\n15.8.2 Emacs和运行期调试371\n15.8.3 Emacs和版本控制371\n15.8.4 Emacs和Profiling372\n15.8.5 像IDE一样，但更强373\n第16章 重用：论不要重新发明轮子375\n16.1 猪小兵的故事376\n16.2 透明性是重用的关键379\n16.3 从重用到开源380\n16.4 生命中最美好的就是“开放”381\n16.5 何处找384\n16.6 使用开源软件的问题385\n16.7 许可证问题386\n16.7.1 开放源码的资格386\n16.7.2 标准开放源码许可证388\n16.7.3 何时需要律师390\nPartⅣ391\n第17章 可移植性：软件可移植性与遵循标准393\n17.1 C语言的演化394\n17.1.1 早期的C语言395\n17.1.2 C语言标准396\n17.2 Unix标准398\n17.2.1 标准和Unix之战398\n17.2.2 庆功宴上的幽灵401\n17.2.3 开源世界的Unix标准402\n17.3 IETF和RFC标准化过程403\n17.4 规格DNA，代码RNA405\n17.5 可移植性编程408\n17.5.1 可移植性和编程语言选择409\n17.5.2 避免系统依赖性412\n17.5.3 移植工具413\n17.6 国际化413\n17.7 可移植性、开放标准以及开放源码414\n第18章 文档：向网络世界阐释代码417\n18.1 文档概念418\n18.2 Unix风格420\n18.2.1 大文档偏爱420\n18.2.2 文化风格421\n18.3 各种Unix文档格式422\n18.3.1 troff和Documenter's Work bench Tools422\n18.3.2 TEX424\n18.3.3 Texinfo425\n18.3.4 POD425\n18.3.5 HTML426\n18.3.6 DocBook426\n18.4 当前的混乱和可能的出路426\n18.5 DocBook427\n18.5.1 文档类型定义427\n18.5.2 其它DTD428\n18.5.3 DocBook工具链429\n18.5.4 移植工具431\n18.5.5 编辑工具432\n18.5.6 相关标准和实践433\n18.5.7 SGML433\n18.5.8 XML—DocBook参考书籍433\n18.6 编写Unix文档的最佳实践434\n第19章 开放源码：在Unix新社区中编程437\n19.1 Unix和开放源码438\n19.2 与开源开发者协同工作的最佳实践440\n19.2.1 良好的修补实践440\n19.2.2 良好的项目、档案文件命名实践444\n19.2.3 良好的开发实践447\n19.2.4 良好的发行制作实践450\n19.2.5 良好的交流实践454\n19.3 许可证的逻辑：如何挑选456\n19.4 为什么应使用某个标准许可证457\n19.5 各种开源许可证457\n19.5.1 MIT或者Xconsortium许可证457\n19.5.2 经典BSD许可证457\n19.5.3 Artistic许可证458\n19.5.4 通用公共许可证458\n19.5.5 Mozilla公共许可证459\n第20章 未来：危机与机遇461\n20.1 Unix传统中的必然和偶然461\n20.2 Plang：未来之路464\n20.3 Unix设计中的问题466\n20.3.1 Unix文件就是一大袋字节466\n20.3.2 Unix对GUI的支持孱弱467\n20.3.3 文件删除不可撤销468\n20.3.4 Unix假定文件系统是静态的469\n20.3.5 作业控制设计拙劣469\n20.3.6 UnixAPI没有使用异常470\n20.3.7 ioctl（2）和fcntl（2）是个尴尬471\n20.3.8 Unix安全模型可能太过原始471\n20.3.9 Unix名字种类太多472\n20.3.10 文件系统可能有害论472\n20.3.11 朝向全局互联网地址空间472\n20.4 Unix的环境问题473\n20.5 Unix文化中的问题475\n20.6 信任的理由477\n附录A 缩写词表479\n附录B 参考文献483\n附录C 贡献者495\n附录D 无根的根：无名师的Unix心传499\nColophon510\n索引511","pages":"530","images":{"small":"https://img1.doubanio.com\/spic\/s11345267.jpg","large":"https://img1.doubanio.com\/lpic\/s11345267.jpg","medium":"https://img1.doubanio.com\/mpic\/s11345267.jpg"},"alt":"https:\/\/book.douban.com\/subject\/11609943\/","id":"11609943","publisher":"电子工业出版社","isbn10":"7121176653","isbn13":"9787121176654","title":"UNIX编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/11609943","alt_title":"The Art of UNIX Programming","author_intro":"Eric S.Raymond，从1982年开始就是UNIX开发者。作为开源社区文化的倡导和呼吁者，他在《大教堂与市集》中写下了这场运动的宣言，同时他还是《新黑客词典》的编辑。","summary":"《UNIX编程艺术》主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S.Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为《UNIX编程艺术》贡献了宝贵的内容。《UNIX编程艺术》内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。","series":{"id":"6628","title":"传世经典书丛"},"price":"99.00元"},{"rating":{"max":10,"numRaters":24,"average":"7.3","min":0},"subtitle":"","author":["海德"],"pubdate":"2005-01-01","tags":[{"count":30,"name":"汇编","title":"汇编"},{"count":19,"name":"编程","title":"编程"},{"count":10,"name":"计算机","title":"计算机"},{"count":4,"name":"汇编语言编程艺术","title":"汇编语言编程艺术"},{"count":4,"name":"Programming","title":"Programming"},{"count":4,"name":"HLA（高级汇编）","title":"HLA（高级汇编）"},{"count":4,"name":"Assembly","title":"Assembly"},{"count":3,"name":"计算机语言","title":"计算机语言"}],"origin_title":"The Art of Assembly Language","image":"https://img3.doubanio.com\/mpic\/s9945721.jpg","binding":"平装","translator":["陈曙晖"],"catalog":"","pages":"776","images":{"small":"https://img3.doubanio.com\/spic\/s9945721.jpg","large":"https://img3.doubanio.com\/lpic\/s9945721.jpg","medium":"https://img3.doubanio.com\/mpic\/s9945721.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1231288\/","id":"1231288","publisher":"清华大学出版社","isbn10":"7302090572","isbn13":"9787302090571","title":"汇编语言编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/1231288","alt_title":"The Art of Assembly Language","author_intro":"","summary":"","price":"98.0"},{"rating":{"max":10,"numRaters":21,"average":"7.8","min":0},"subtitle":"C++编程艺术","author":["斯切尔特"],"pubdate":"2005-4","tags":[{"count":14,"name":"C++","title":"C++"},{"count":8,"name":"编程","title":"编程"},{"count":8,"name":"C\/C++","title":"C\/C++"},{"count":3,"name":"软件研发","title":"软件研发"},{"count":3,"name":"计算机","title":"计算机"},{"count":2,"name":"编程思想","title":"编程思想"},{"count":2,"name":"程序设计","title":"程序设计"},{"count":2,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s5721129.jpg","binding":"简裝本","translator":["曹蓉蓉","刘小荷"],"catalog":"","pages":"325","images":{"small":"https://img1.doubanio.com\/spic\/s5721129.jpg","large":"https://img1.doubanio.com\/lpic\/s5721129.jpg","medium":"https://img1.doubanio.com\/mpic\/s5721129.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1444929\/","id":"1444929","publisher":"清华大学出版社","isbn10":"7302100179","isbn13":"9787302100171","title":"C++编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/1444929","alt_title":"","author_intro":"Herbert Schildt 全球顶尖编程图书作者之一。他是C、C++、Java和C#编程语言的权威，也是windows编程方面的专家。他的编程图书被译为多国语言，在世界范围内的销量已经超过300万册。","summary":"本书揭示了C++程序员创建世界级软件的奥秘。程序设计大师Herbert Schildt通过将C++语言广泛应用于功能强大的编程任务中，全面展示了C++语言的多功能性，敏捷性，和艺术性。本书内容包括探索C++的功能，创建内存管理的垃圾回收器子系统，开发线程控制面板，建立译码器以扩展C++的功能，开发可断点续传的Internet文件下载工具，创建财务分析库，用基于AI的搜索技术探索人工智能，建立定制的STL容器，以及开发Mini C++解释程序。书中所有示例和项目的源代码都可以从www.osborne.com 上免费下载。","price":"39.80元"},{"rating":{"max":10,"numRaters":6,"average":"0.0","min":0},"subtitle":"","author":["作　者： [美]Randall Hyde"],"pubdate":"2011-12-1","tags":[{"count":14,"name":"汇编","title":"汇编"},{"count":5,"name":"编程","title":"编程"},{"count":4,"name":"HLA","title":"HLA"},{"count":3,"name":"程序设计","title":"程序设计"},{"count":3,"name":"汇编语言","title":"汇编语言"},{"count":3,"name":"ASM","title":"ASM"},{"count":2,"name":"高层汇编","title":"高层汇编"},{"count":2,"name":"计算机","title":"计算机"}],"origin_title":"The Art of Assembly Language","image":"https://img1.doubanio.com\/mpic\/s7058839.jpg","binding":"平装","translator":["包战","马跃"],"catalog":"第1章 进入汇编语言的世界 1\n1.1 hla程序的结构 1\n1.2 运行第一个hla程序 3\n1.3 基本的hla数据声明 4\n1.4 布尔值 6\n1.5 字符值 6\n1.6 intel 80x86 cpu系列简介 6\n1.7 存储子系统 9\n1.8 基本的机器指令 11\n1.9 基本的hla控制结构 14\n1.9.1 hla语句中的布尔表达式 14\n1.9.2 hla中的if..then..elseif..else..endif语句 16\n1.9.3 布尔表达式中的逻辑与、逻辑或以及逻辑非 18\n1.9.4 while..endwhile语句 20\n1.9.5 for..endfor语句 20\n1.9.6 repeat..until语句 21\n1.9.7 break和breakif语句 22\n1.9.8 forever..endfor语句 22\n1.9.9 try..exception..endtry语句 23\n1.10 hla标准库入门 26\n1.10.1 stdio模块中的预定义常量 28\n1.10.2 标准输入和标准输出 29\n1.10.3 stdout.newln例程 29\n1.10.4 stdout.putix例程 29\n1.10.5 stdout.putixsize例程 29\n1.10.6 stdout.put例程 31\n1.10.7 stdin.getc例程 32\n1.10.8 stdin.getix例程 33\n1.10.9 stdin.readln和stdin.flushinput例程 34\n1.10.10 stdin.get例程 35\n1.11 关于try..endtry的其他细节 35\n1.11.1 try..endtry嵌套语句 36\n1.11.2 try..endtry语句中不受保护的子句 38\n1.11.3 try..endtry语句中的anyexception子句 40\n1.11.4 寄存器与try..endtry语句 41\n1.12 高级汇编语言与低级汇编语言的比较 42\n1.13 更多信息 43\n第2章 数据表示 45\n2.1 数字系统 45\n2.1.1 回顾十进制系统 45\n2.1.2 二进制数字系统 46\n2.1.3 二进制格式 47\n2.2 十六进制数字系统 47\n2.3 数据结构 49\n2.3.1 位 49\n2.3.2 半字节 50\n2.3.3 字节 51\n2.3.4 字 52\n2.3.5 双字 53\n2.3.6 四字和长字 53\n2.4 二进制数和十六进制数的算术运算 54\n2.5 关于数字及其表示 55\n2.6 位逻辑运算 57\n2.7 二进制数和位串的逻辑运算 59\n2.8 有符号数和无符号数 61\n2.9 符号扩展、零扩展、压缩和饱和 65\n2.10 移位和循环移位 68\n2.11 位域和压缩数据 72\n2.12 浮点运算简介 76\n2.12.1 ieee浮点格式 79\n2.12.2 hla为浮点数值提供的支持 81\n2.13 bcd数据表示 84\n2.14 字符 85\n2.14.1 ascii字符编码 85\n2.14.2 hla对ascii字符提供的支持 88\n2.15 unicode字符集 91\n2.16 更多信息 92\n第3章 存储器的访问与结构 93\n3.1 80x86的寻址方式 93\n3.1.1 80x86寄存器寻址方式 94\n3.1.2 80x86的32位存储器寻址方式 94\n3.2 运行时存储器的结构 100\n3.2.1 代码段 101\n3.2.2 静态段 102\n3.2.3 只读数据段 103\n3.2.4 存储段 103\n3.2.5 @nostorage属性 104\n3.2.6 var段 104\n3.2.7 程序中声明段的结构 105\n3.3 hla如何为变量分配内存 106\n3.4 hla对数据对齐的支持 107\n3.5 地址表达式 109\n3.6 类型强制转换 111\n3.7 寄存器类型强制转换 113\n3.8 栈段与push和pop指令 114\n3.8.1 基本的push指令 114\n3.8.2 基本的pop指令 115\n3.8.3 用push和pop指令保护寄存器 116\n3.9 栈的lifo数据结构 117\n3.9.1 其他的push和pop指令 118\n3.9.2 不使用出栈而从栈内移除数据 119\n3.10 访问已入栈而未出栈的数据 120\n3.11 动态内存分配和堆段 122\n3.12 inc和dec指令 125\n3.13 获取存储器对象的地址 125\n3.14 更多信息 126\n第4章 常量、变量与数据类型 127\n4.1 一些额外的指令：intmul、bound、into 127\n4.2 hla常量和数值声明 131\n4.2.1 常量类型 134\n4.2.2 字符串和字符字面常量 135\n4.2.3 const段中的字符串常量与文本常量 137\n4.2.4 常量表达式 138\n4.2.5 hla程序中的多个const段以及它们的顺序 140\n4.2.6 hla的val段 140\n4.2.7 在程序中的任意位置修改val对象 141\n4.3 hla的type段 142\n4.4 enum和hla枚举数据类型 143\n4.5 指针数据类型 144\n4.5.1 在汇编语言中使用指针 145\n4.5.2 在hla中声明指针 146\n4.5.3 指针常量和指针常量表达式 146\n4.5.4 指针变量和动态内存分配 147\n4.5.5 指针的常见问题 147\n4.6 复合数据类型 151\n4.7 字符串 151\n4.8 hla字符串 154\n4.9 访问字符串中的字符 159\n4.10 hla字符串模块和其他与字符串相关的例程 160\n4.11 存储器内的转换 170\n4.12 字符集 171\n4.13 在hla中实现字符集 172\n4.14 hla字符集常量和字符集表达式 173\n4.15 hla标准库对字符集的支持 175\n4.16 在hla程序中使用字符集 177\n4.17 数组 178\n4.18 在hla程序中声明数组 179\n4.19 hla数组常量 180\n4.20 访问一维数组的元素 181\n4.21 数组排序 182\n4.22 多维数组 183\n4.22.1 以行为主排列 184\n4.22.2 以列为主排列 187\n4.23 多维数组的存储空间分配 187\n4.24 汇编语言中多维数组元素的访问 189\n4.25 记录 190\n4.26 记录常量 192\n4.27 记录数组 193\n4.28 数组\/记录作为记录字段 194\n4.29 对齐记录中的字段 197\n4.30 记录指针 198\n4.31 联合 200\n4.32 匿名联合 202\n4.33 变体类型 203\n4.34 命名空间 203\n4.35 汇编语言中的动态数组 206\n4.36 更多信息 208\n第5章 过程和单元 209\n5.1 过程 209\n5.2 机器状态的保存 211\n5.3 过程的提前返回 215\n5.4 局部变量 215\n5.5 其他局部和全局符号类型 220\n5.6 参数 220\n5.6.1 值传递 221\n5.6.2 引用传递 224\n5.7 函数和函数的结果 226\n5.7.1 返回函数结果 227\n5.7.2 hla中的指令合成 227\n5.7.3 hla过程的@returns选项 229\n5.8 递归 231\n5.9 过程的向前引用 235\n5.10 hla v2.0的过程声明 236\n5.11 过程的底层实现与call指令 236\n5.12 过程与栈 238\n5.13 活动记录 240\n5.14 标准入口序列 242\n5.15 标准出口序列 244\n5.16 自动(局部)变量的底层实现 245\n5.17 参数的底层实现 246\n5.17.1 在寄存器中传递参数 247\n5.17.2 在代码流中传递参数 249\n5.17.3 在栈中传递参数 251\n5.18 过程指针 269\n5.19 过程参数 272\n5.20 无类型的引用参数 273\n5.21 管理大型程序 274\n5.22 #include伪指令 274\n5.23 忽略重复的#include操作 276\n5.24 单元与external伪指令 276\n5.24.1 伪指令external的行为 280\n5.24.2 hla中的头文件 281\n5.25 命名空间污染 282\n5.26 更多信息 284\n第6章 算术运算 287\n6.1 80x86的整数运算指令 287\n6.1.1 mul和imul指令 287\n6.1.2 div和idiv指令 290\n6.1.3 cmp指令 292\n6.1.4 setcc指令 296\n6.1.5 test指令 298\n6.2 算术表达式 299\n6.2.1 简单赋值 300\n6.2.2 简单表达式 300\n6.2.3 复杂表达式 302\n6.2.4 可交换运算符 307\n6.3 逻辑(布尔)表达式 308\n6.4 机器特性与运算技巧 309\n6.4.1 不使用mul、imul或intmul的乘法 310\n6.4.2 不使用div或idiv的除法 311\n6.4.3 使用and实现模n计数器 311\n6.5 浮点运算 312\n6.5.1 fpu寄存器 312\n6.5.2 fpu的数据类型 317\n6.5.3 fpu的指令集 318\n6.5.4 fpu的数据转移指令 318\n6.5.5 换算指令 320\n6.5.6 算术运算指令 322\n6.5.7 比较指令 327\n6.5.8 常量指令 329\n6.5.9 超越指令 329\n6.5.10 其他指令 331\n6.5.11 整数操作 332\n6.6 将浮点表达式转换成汇编语言 332\n6.6.1 将算术表达式转换成后缀表示法 334\n6.6.2 将后缀表达式转换成汇编语言 335\n6.7 hla标准库对浮点算术运算的支持 336\n6.8 更多信息 337\n第7章 低级控制结构 339\n7.1 低级控制结构 339\n7.2 语句标号 339\n7.3 无条件控制转移(jmp) 341\n7.4 条件跳转指令 343\n7.5 “中级”控制结构：jt和jf 346\n7.6 使用汇编语言实现常用控制结构 347\n7.7 判定 347\n7.7.1 if..then..else序列 348\n7.7.2 将hla的if语句翻译成纯汇编语言 351\n7.7.3 使用完整布尔求值实现复杂的if语句 355\n7.7.4 短路布尔求值 356\n7.7.5 短路布尔求值与完整布尔求值 357\n7.7.6 汇编语言中if语句的高效实现 359\n7.7.7 switch\/case语句 363\n7.8 状态机和间接跳转 372\n7.9 “意大利面条式”代码 375\n7.10 循环 375\n7.10.1 while循环 376\n7.10.2 repeat..until循环 377\n7.10.3 forever..endfor循环 378\n7.10.4 for循环 378\n7.10.5 break和continue语句 379\n7.10.6 寄存器的使用与循环 383\n7.11 性能提高 384\n7.11.1 将结束条件判断放在循环结尾 384\n7.11.2 反向执行循环 386\n7.11.3 循环不变计算 387\n7.11.4 循环展开 388\n7.11.5 归纳变量 389\n7.12 hla中的混合控制结构 390\n7.13 更多信息 392\n第8章 高级算术运算 393\n8.1 多精度操作 393\n8.1.1 扩展精度操作的hla标准库支持 394\n8.1.2 多精度加法运算 396\n8.1.3 多精度减法运算 398\n8.1.4 扩展精度比较操作 399\n8.1.5 扩展精度乘法操作 403\n8.1.6 扩展精度除法操作 406\n8.1.7 扩展精度neg操作 414\n8.1.8 扩展精度and操作 415\n8.1.9 扩展精度or操作 415\n8.1.10 扩展精度xor操作 416\n8.1.11 扩展精度not操作 416\n8.1.12 扩展精度移位操作 416\n8.1.13 扩展精度循环移位操作 419\n8.1.14 扩展精度i\/o 420\n8.2 对不同长度的操作数进行操作 437\n8.3 十进制算术运算 439\n8.3.1 字面bcd常量 440\n8.3.2 80x86的daa指令和das指令 441\n8.3.3 80x86的aaa、aas、aam和aad指令 442\n8.3.4 使用fpu的压缩十进制算术操作 443\n8.4 表 445\n8.4.1 通过表查找进行函数计算 445\n8.4.2 域调节 449\n8.4.3 产生表 450\n8.4.4 表查找的性能 453\n8.5 更多信息 453\n第9章 宏与hla编译时语言 455\n9.1 编译时语言 455\n9.2 #print和#error语句 457\n9.3 编译时常量和变量 458\n9.4 编译时表达式和操作符 458\n9.5 编译时函数 461\n9.5.1 类型转换编译时函数 462\n9.5.2 数值编译时函数 463\n9.5.3 字符分类编译时函数 463\n9.5.4 编译时字符串函数 463\n9.5.5 编译时符号信息 464\n9.5.6 其他编译时函数 465\n9.5.7 编译时文本对象的类型转换 465\n9.6 条件编译(编译时判定) 467\n9.7 重复编译(编译时循环) 470\n9.8 宏(编译时过程) 473\n9.8.1 标准宏 473\n9.8.2 宏参数 475\n9.8.3 宏中的局部符号 480\n9.8.4 作为编译时过程的宏 482\n9.8.5 使用宏模拟函数重载 483\n9.9 编写编译时“程序” 488\n9.9.1 在编译时构造数据表 488\n9.9.2 循环展开 492\n9.10 在不同的源文件中使用宏 493\n9.11 更多信息 493\n第10章 位操作 495\n10.1 位数据 495\n10.2 位操作指令 496\n10.3 作为位累加器的进位标志 502\n10.4 位串的压缩与解压缩 503\n10.5 接合位组与分布位串 506\n10.6 压缩的位串数组 508\n10.7 搜索位 510\n10.8 位的计数 512\n10.9 倒置位串 515\n10.10 合并位串 517\n10.11 提取位串 517\n10.12 搜索位模式 519\n10.13 hla标准库的位模块 520\n10.14 更多信息 522\n第11章 字符串指令 523\n11.1 80x86字符串指令 523\n11.1.1 字符串指令的操作过程 524\n11.1.2 rep\/repe\/repz和repnz\/repne前缀 524\n11.1.3 方向标志 525\n11.1.4 movs指令 527\n11.1.5 cmps指令 531\n11.1.6 scas指令 534\n11.1.7 stos指令 534\n11.1.8 lods指令 535\n11.1.9 通过lods和stos构建复杂 的字符串函数 536\n11.2 80x86字符串指令的性能 536\n11.3 更多信息 536\n第12章 类与对象 539\n12.1 通用原则 539\n12.2 hla中的类 541\n12.3 对象 543\n12.4 继承 545\n12.5 重写 546\n12.6 虚拟方法与静态过程 547\n12.7 编写类方法和过程 548\n12.8 对象实现 552\n12.8.1 虚拟方法表 554\n12.8.2 带继承的对象表示 556\n12.9 构造函数和对象初始化 560\n12.9.1 构造函数中的动态对象 分配 561\n12.9.2 构造函数和继承 563\n12.9.3 构造函数的参数和过程 重载 566\n12.10 析构函数 566\n12.11 hla的_initialize_和_finalize_ 字符串 567\n12.12 抽象方法 572\n12.13 运行时类型信息 574\n12.14 调用基类的方法 576\n12.15 更多信息 577\n附录 ascii字符集 579","pages":"582","images":{"small":"https://img1.doubanio.com\/spic\/s7058839.jpg","large":"https://img1.doubanio.com\/lpic\/s7058839.jpg","medium":"https://img1.doubanio.com\/mpic\/s7058839.jpg"},"alt":"https:\/\/book.douban.com\/subject\/7059709\/","id":"7059709","publisher":"清华大学出版社","isbn10":"7302263736","isbn13":"9787302263739","title":"汇编语言的编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/7059709","alt_title":"The Art of Assembly Language","author_intro":"海德，Randall Hyde是《Write Great Code》Volumes 1和Volumes 2的作者，并且与人合著了MASM 6.0 Bible。他为Dr．Dobb’s Journal、Byte和多种专业刊物撰稿。他在加州大学河滨分校讲授汇编语言已经超过了十年的时间。","summary":"《汇编语言的编程艺术(第2版)》内容简介：汇编语言是一种低级编程语言，只比计算机本身的机器语言高一级。虽然汇编语言经常用于编写设备驱动程序、模拟器和视频游戏，但是许多程序员认为汇编语言的语法不太友好，很难学习和使用。\n1996年以来，randall hyde的《汇编语言的编程艺术》一书为非汇编程序员提供了全面、易读和循序渐进的32位x86汇编语言的介绍。hyde使用的主要教学工具是高级语言汇编器(highlevelassembler，hla)，其中提供了许多高级语言(如c、c++和java)的功能，以帮助读者快速掌握汇编语言的基本概念。hla在允许汇编语言程序员编写真正低级代码的同时，也使他们能够利用高级语言编程的优势。\n通过阅读《汇编语言的编程艺术(第2版)》，读者可以学到计算机科学的底层理论基础，并将所学知识转化为真正可以运行的代码。\n《汇编语言的编程艺术(第2版)》内容、编辑、编译和运行hla程序声明和使用常量、标量变量、指针、数组、结构、联合和命名空间、转换算术表达式(整型和浮点型)、转换高级控制结构。\n《汇编语言的编程艺术(第2版)》是汇编语言学习者翘首以盼的《汇编语言的编程艺术》的第2版。与第1版相比，《汇编语言的编程艺术(第2版)》新增了反映hla最新变化的内容，并介绍了如何支持linux、macosx和freebsd。汇编语言是一门复杂的低级语言，但是无论读者是否具有高级语言编程经验，都可以借助《汇编语言的编程艺术(第2版)》掌握它。","price":"69.80元"},{"rating":{"max":10,"numRaters":5,"average":"0.0","min":0},"subtitle":"深入理解数据库体系结构","author":["Thomas Kyte","Darl Kuhn"],"pubdate":"2016-4","tags":[{"count":15,"name":"Oracle","title":"Oracle"},{"count":5,"name":"数据库","title":"数据库"},{"count":3,"name":"数据库书单","title":"数据库书单"},{"count":3,"name":"DB","title":"DB"},{"count":1,"name":"计算机","title":"计算机"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s28667378.jpg","binding":"","translator":["朱龙春","张宏伟","苗朋","陈刚"],"catalog":"第1章　开发成功的Oracle应用　　1\n1.1　我的方法　　2\n1.2　黑盒方法　　3\n1.3　开发数据库应用的正确（和不正确）方法　　11\n1.3.1　了解Oracle体系结构　　11\n1.3.2　理解并发控制　　21\n1.3.3　多版本控制　　25\n1.3.4　数据库独立性　　31\n1.3.5　怎么能让应用运行得更快45\n1.3.6　DBA与开发人员的关系　　48\n1.4　小结　　48\n第2章　体系结构概述　　50\n2.1　定义数据库和实例　　51\n2.2　连接Oracle　　59\n2.2.1　专用服务器　　59\n2.2.2　共享服务器　　61\n2.2.3　TCP\/IP连接的基本原理　　63\n2.3　可插拔式数据库　　65\n2.3.1　降低资源用量　　66\n2.3.2　降低维护开销　　66\n2.4　可插拔式数据库的不同之处　　67\n2.5　小结　　67\n第3章　文件　　68\n3.1　参数文件　　69\n3.1.1　什么是参数　　70\n3.1.2　init.ora参数文件　　73\n3.1.3　服务器参数文件　　75\n3.2　跟踪文件　　82\n3.2.1　计划内的、由用户请求所产生的跟踪文件　　83\n3.2.2　针对内部错误生成的跟踪文件　　88\n3.2.3　跟踪文件小结　　92\n3.3　警告文件　　92\n3.4　数据文件　　95\n3.4.1　简要回顾文件系统机制　　96\n3.4.2　Oracle数据库中的存储层次体系　　97\n3.4.3　字典管理和本地管理的表空间　　100\n3.5　临时文件　　102\n3.6　控制文件　　104\n3.7　重做日志文件　　104\n3.7.1　在线重做日志　　105\n3.7.2　归档重做日志　　107\n3.8　密码文件　　108\n3.9　修改跟踪文件　　111\n3.10　闪回日志　　112\n3.10.1　闪回数据库　　112\n3.10.2　快速恢复区　　113\n3.11　DMP文件（EXP\/IMP 文件）　　114\n3.12　数据泵文件　　115\n3.13　平面文件　　117\n3.14　小结　　118\n第4章　内存结构　　119\n4.1　进程全局区和用户全局区　　120\n4.1.1　手动PGA内存管理　　121\n4.1.2　自动PGA内存管理　　127\n4.1.3　如何选择手动和自动内存管理　　137\n4.1.4　PGA和UGA小结　　138\n4.2　系统全局区　　138\n4.2.1　固定SGA 区　　143\n4.2.2　重做缓冲区　　143\n4.2.3　块缓冲区缓存　　145\n4.2.4　共享池　　151\n4.2.5　大池　　153\n4.2.6　Java池　　154\n4.2.7　流池　　155\n4.2.8　SGA内存管理　　155\n4.3　小结　　160\n第5章　Oracle 进程　　161\n5.1　服务器进程　　161\n5.1.1　专用服务器连接　　162\n5.1.2　共享服务器连接　　164\n5.1.3　数据库常驻连接池　　165\n5.1.4　连接与会话　　165\n5.1.5　专用服务器、共享服务器和数据库常驻连接池　　170\n5.1.6　专用\/共享服务器小结　　173\n5.2　后台进程　　174\n5.2.1　特定任务后台进程　　175\n5.2.2　工具后台进程　　185\n5.3　从属进程　　188\n5.3.1　I\/O从属进程　　188\n5.3.2　Pnnn：并行查询执行服务器　　189\n5.4　小结　　189\n第6章　锁和闩　　190\n6.1　什么是锁　　190\n6.2　锁的问题　　193\n6.2.1　丢失更新　　193\n6.2.2　悲观锁　　194\n6.2.3　乐观锁　　195\n6.2.4　乐观锁还是悲观锁　　201\n6.2.5　阻塞　　202\n6.2.6　死锁　　205\n6.2.7　锁升级　　209\n6.3　锁类型　　209\n6.3.1　DML锁　　210\n6.3.2　DDL锁　　219\n6.3.3　闩　　223\n6.3.4　互斥锁　　231\n6.3.5　手动锁定和用户定义锁　　232\n6.4　小结　　233\n第7章　并发与多版本控制　　234\n7.1　什么是并发控制　　234\n7.2　事务隔离级别　　235\n7.2.1　READ UNCOMMITTED　　236\n7.2.2　READ COMMITTED　　238\n7.2.3　REPEATABLE READ　　239\n7.2.4　SERIALIZABLE　　241\n7.2.5　READ ONLY　　243\n7.3　多版本读一致性的含义　　244\n7.3.1　数据仓库中一种常见但有问题的方法　　244\n7.3.2　解释热表上超出期望的I\/O　　245\n7.4　写一致性　　247\n7.4.1　一致读和当前读　　248\n7.4.2　查看重启动　　250\n7.4.3　为什么重启动对我们很重要　　252\n7.5　小结　　253\n第8章　事务　　255\n8.1　事务控制语句　　255\n8.2　原子性　　257\n8.2.1　语句级原子性　　257\n8.2.2　过程级原子性　　259\n8.2.3　事务级原子性　　262\n8.2.4　DDL与原子性　　262\n8.3　持久性　　263\n8.3.1　COMMIT的WRITE扩展　　263\n8.3.2　非分布式PL\/SQL代码块中的COMMIT　　264\n8.4　完整性约束和事务　　266\n8.4.1　IMMEDIATE约束　　266\n8.4.2　DEFERRABLE约束和级联更新　　266\n8.5　不好的事务习惯　　270\n8.5.1　在循环中提交　　270\n8.5.2　使用自动提交　　276\n8.6　分布式事务　　277\n8.7　自治事务　　278\n8.7.1　自治事务如何工作　　279\n8.7.2　何时使用自治事务　　280\n8.8　小结　　283\n第9章　redo与undo　　284\n9.1　什么是redo　　285\n9.2　什么是undo　　286\n9.3　redo和undo如何协作　　289\n9.4　提交和回滚处理　　293\n9.4.1　COMMIT做什么　　293\n9.4.2　ROLLBACK做什么　　299\n9.5　分析redo　　300\n9.5.1　测量redo　　301\n9.5.2　能关掉重做日志的生成吗　　302\n9.5.3　为什么我拿不到日志空间　　305\n9.5.4　块清除　　307\n9.5.5　日志竞争　　310\n9.5.6　临时表和redo\/undo　　312\n9.6　分析undo　　317\n9.6.1　什么操作会生成最多和最少的undo　　317\n9.6.2　ORA-01555: snapshot too old错误　　319\n9.7　小结　　328\n第10章　数据库表　　329\n10.1　表类型　　329\n10.2　术语　　331\n10.2.1　段　　331\n10.2.2　段空间管理　　333\n10.2.3　高水位线　　334\n10.2.4　FREELIST　　336\n10.2.5　PCTFREE和PCTUSED　　339\n10.2.6　LOGGING和NOLOGGING　　342\n10.2.7　INITRANS和MAXTRANS　　343\n10.3　堆组织表　　343\n10.4　索引组织表　　346\n10.5　索引聚簇表　　359\n10.6　散列聚簇表　　366\n10.7　有序散列聚簇表　　375\n10.8　嵌套表　　377\n10.8.1　嵌套表语法　　378\n10.8.2　嵌套表存储　　384\n10.8.3　嵌套表小结　　387\n10.9　临时表　　387\n10.9.1　12c之前的统计信息　　391\n10.9.2　12c之后的统计信息　　395\n10.9.3　临时表小结　　398\n10.10　对象表　　399\n10.11　小结　　405\n第11章　索引　　406\n11.1　Oracle索引概述　　406\n11.2　B*Tree索引　　408\n11.2.1　索引键压缩　　411\n11.2.2　反向键索引　　413\n11.2.3　降序索引　　418\n11.2.4　什么情况下应该使用B*Tree索引　　420\n11.2.5　B*Tree小结　　430\n11.3　位图索引　　430\n11.3.1　什么情况下应该使用位图索引　　431\n11.3.2　位图联结索引　　435\n11.3.3　位图索引小结　　437\n11.4　基于函数的索引　　438\n11.4.1　一个简单的例子　　438\n11.4.2　只对部分行建立索引　　446\n11.4.3　实现有选择的唯一性　　448\n11.4.4　关于ORA-01743的警告　　448\n11.4.5　基于函数的索引小结　　449\n11.5　应用域索引　　450\n11.6　不可见的索引　　451\n11.7　同列上的多个索引　　452\n11.8　在扩展列上使用索引　　453\n11.8.1　使用虚拟列的方法　　454\n11.8.2　使用基于函数索引的方法　　456\n11.9　关于索引的常见问题和各种传言　　457\n11.9.1　视图能使用索引吗　　457\n11.9.2　Null和索引能协作吗　　457\n11.9.3　外键是否应该加索引　　460\n11.9.4　为什么没有使用我的索引　　461\n11.9.5　传言：索引中从不重用空间　　466\n11.9.6　传言：最有差别的元素应该在最前面　　469\n11.10　小结　　472\n第12章　数据类型　　473\n12.1　Oracle数据类型概述　　473\n12.2　字符和二进制串类型　　475\n12.2.1　NLS概述　　476\n12.2.2　字符串　　479\n12.3　二进制串：RAW类型　　485\n12.4　扩展的数据类型　　487\n12.5　数值类型　　489\n12.5.1　NUMBER类型的语法和用法　　491\n12.5.2　BINARY_FLOAT\/BINARY_DOUBLE类型的语法和用法　　494\n12.5.3　非固有数值类型　　495\n12.5.4　性能考虑　　495\n12.6　LONG类型　　497\n12.6.1　LONG 和LONG RAW类型的限制　　497\n12.6.2　处理遗留的LONG类型　　498\n12.7　DATE、TIMESTAMP和INTERVAL类型　　502\n12.7.1　格式　　503\n12.7.2　DATE类型　　504\n12.7.3　TIMESTAMP类型　　509\n12.7.4　INTERVAL类型　　515\n12.8　LOB类型　　518\n12.8.1　内部LOB　　518\n12.8.2　BFILE　　531\n12.9　ROWID\/UROWID类型　　533\n12.10　小结　　533\n第13章　分区　　535\n13.1　分区概述　　535\n13.1.1　提高可用性　　536\n13.1.2　减少管理负担　　538\n13.1.3　增强语句性能　　541\n13.2　表分区机制　　543\n13.2.1　区间分区　　544\n13.2.2　散列分区　　546\n13.2.3　列表分区　　550\n13.2.4　间隔分区　　552\n13.2.5　引用分区　　557\n13.2.6　间隔引用分区　　561\n13.2.7　虚拟列分区　　563\n13.2.8　组合分区　　564\n13.2.9　行移动　　566\n13.2.10　表分区机制小结　　568\n13.3　索引分区　　569\n13.3.1　本地索引与全局索引　　570\n13.3.2　本地索引　　570\n13.3.3　全局索引　　575\n13.4　再论分区和性能　　590\n13.5　一些简化维护的特性　　595\n13.5.1　多分区管理操作　　595\n13.5.2　级联截断　　597\n13.5.3　级联交换　　599\n13.6　审计和段空间压缩　　600\n13.7　小结　　601\n第14章　并行执行　　603\n14.1　何时使用并行执行　　604\n14.2　Oracle Exadata　　606\n14.3　并行查询　　606\n14.4　并行DML　　612\n14.5　并行DDL　　615\n14.5.1　并行DDL和使用外部表的数据加载　　616\n14.5.2　并行DDL和扩展截断　　617\n14.6　过程并行化　　625\n14.6.1　并行管道函数　　626\n14.6.2　DIY并行化　　629\n14.6.3　老式DIY并行化　　632\n14.7　小结　　635\n第15章　数据加载和卸载　　637\n15.1　外部表　　637\n15.1.1　建立外部表　　638\n15.1.2　处理错误　　645\n15.1.3　使用外部表加载不同的文件　　648\n15.1.4　多用户问题　　649\n15.1.5　预处理　　650\n15.1.6　外部表总结　　658\n15.2　数据泵卸载　　659\n15.3　SQLLDR　　660\n15.3.1　用SQLLDR加载数据的常见问题　　664\n15.3.2　SQLLDR警告　　686\n15.3.3　SQLLDR小结　　686\n15.4　平面文件卸载　　687\n15.5　小结　　694","pages":"732","images":{"small":"https://img1.doubanio.com\/spic\/s28667378.jpg","large":"https://img1.doubanio.com\/lpic\/s28667378.jpg","medium":"https://img1.doubanio.com\/mpic\/s28667378.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26775661\/","id":"26775661","publisher":"人民邮电出版社","isbn10":"7115419574","isbn13":"9787115419576","title":"Oracle编程艺术：深入理解数据库体系结构（第3版）","url":"https:\/\/api.douban.com\/v2\/book\/26775661","alt_title":"","author_intro":"作者简介：\nThomas Kyte\n著名Oracle数据库大师，长期主持Oracle Magazine“Ask Tom”专栏，热心回答困扰全世界Oracle开发人员和DBA的各种问题。曾任Oracle公司核心技术集团副总裁。从5.1.5c版本开始使用Oracle，自7.0.9版本发布至2015年8月一直任职于Oracle公司，帮助Oracle数据库用户设计和构建系统，或者对系统进行重构和调优。此前他曾是一位系统集成师，主要为美国军方和政府部门的客户构建大规模的异构数据库和应用。\nDarl Kuhn\nOracle公司DBA，同时也在美国瑞吉斯大学教授Oracle相关课程。他乐于分享知识，著有多本数据库相关书籍，如《深入理解Oracle 12c数据库管理（第2版）》《Oracle Database 12c性能优化攻略》等。\n译者简介：\n朱龙春（Oracle老朱）\n原Oracle公司首席架构师，现任北京九易云拓科技有限公司技术副总裁。1997年开始接触Oracle\/SAP，国内首位被Oracle官方授予ERP领域Oracle ACE称号。在Oracle公司任职7年，期间主管SAP\/Oracle ERP on Exadata技术团队，专注ERP移动化技术研究，主导开创和实施过具有里程碑意义的国内首个SAP on Exadata项目和国内首个Oracle ERP on Exadata\/Exalogic等ERP应用与私有云平台集成的项目。曾耗时4年撰写《Oracle E-Business Suite: ERP DBA实践指南》。该书是国内首本ERP DBA实践书籍。\n张宏伟\nOracle解决方案中心高级技术经理，1998年开始从事Oracle相关工作，曾工作于通讯金融等行业。做过程序开发、数据库管理、项目经理和架构师。Oracle数据库大师认证（OCM）。\n苗朋\nOracle研发中心首席数据库工程师，14年工作经验，主要研究Oracle数据库、Exadata、云计算、ASM、RAC等产品的新特性测试、故障诊断、性能调优以及架构审阅等。\n陈刚\nOracle研发中心资深技术QA，14年软件开发及数据库研究经验。对Oracle数据库、RAC、EM、DBaaS以及云计算的体系结构有深入研究。","summary":"本书是一本关于Oracle数据库体系结构的权威图书，涵盖了所有重要的Oracle体系结构特性，包括文件、内存结构和进程、锁和闩、事务、并发和多版本、表和索引、数据类型、分区和并行，以及数据加载和卸载，并利用具体的例子来全面介绍每个特性，不仅讨论了各个特性是什么，还说明了它是如何工作的，如何使用这个特性来开发软件，以及有关的常见陷阱。\n本书的读者对象是数据库开发人员。","price":""},{"rating":{"max":10,"numRaters":13,"average":"6.9","min":0},"subtitle":"","author":["高永强"],"pubdate":"2009-7","tags":[{"count":9,"name":"JAVA","title":"JAVA"},{"count":2,"name":"科技","title":"科技"},{"count":2,"name":"Java","title":"Java"},{"count":1,"name":"好","title":"好"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s4457802.jpg","binding":"","translator":[],"catalog":"","pages":"759","images":{"small":"https://img3.doubanio.com\/spic\/s4457802.jpg","large":"https://img3.doubanio.com\/lpic\/s4457802.jpg","medium":"https://img3.doubanio.com\/mpic\/s4457802.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3867972\/","id":"3867972","publisher":"","isbn10":"7302193177","isbn13":"9787302193173","title":"Java编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/3867972","alt_title":"","author_intro":"","summary":"《Java编程艺术》共分5个部分。第1部分为新手上路篇，介绍Java编程基础和环境。第2部分为深入篇，将带领你走进Java面向对象编程大门。第4部分为GUI和多媒体，按钮、菜单、文本选项等20多种GUI组件，以及颜色、字体、图像和声音编程，使你进入一个五彩缤纷、绘声绘色的Java编程艺术世界。第5部分为数据流和处理，指导你掌握Java文件I\/O、数据库编程以及网络编程。\n除涵盖广泛的Java编程概念和技术外，《Java编程艺术》还具有如下几个特点：一是利用3W（What, Why and How）为主线引导对Java语言的学习；二是利用图示化方式讨论面向对象编程技术（Object-Oriented Program-ming）；三是在几乎每章最后，都包括了解决实际问题的实例，综合性地介绍了如何利用在该章讨论过的概念和编程技术来解决实际问题。四是在每章后的巩固提高练习中，进一步指导读者理解、消化以及深入掌握本章程序讨论过的编程概念和例子。\n《Java编程艺术》适用于初学者以及有一定编程基础的读者。可以作为大学、大专、中专以及培训中心作为教科书、自学课本，也可以作为专业人员和教师的参考书。","price":"89.00元"},{"rating":{"max":10,"numRaters":10,"average":"7.7","min":0},"subtitle":"","author":["赵英杰"],"pubdate":"2006-7","tags":[{"count":3,"name":"web","title":"web"},{"count":3,"name":"ActionScript3","title":"ActionScript3"},{"count":2,"name":"flash","title":"flash"},{"count":1,"name":"风云Flash","title":"风云Flash"},{"count":1,"name":"电脑","title":"电脑"},{"count":1,"name":"技术","title":"技术"},{"count":1,"name":"学习类","title":"学习类"},{"count":1,"name":"Flash","title":"Flash"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s10053029.jpg","binding":"平装","translator":[],"catalog":"","pages":"286","images":{"small":"https://img1.doubanio.com\/spic\/s10053029.jpg","large":"https://img1.doubanio.com\/lpic\/s10053029.jpg","medium":"https://img1.doubanio.com\/mpic\/s10053029.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1882597\/","id":"1882597","publisher":"第1版 (2006年7月1日)","isbn10":"7121025531","isbn13":"9787121025532","title":"风云Flash ActionScript高级编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/1882597","alt_title":"","author_intro":"","summary":"本书从基本的Actionscript语言概念开始介绍，配以实际的程序实例并穿插生动的图示说明，深入浅出地讲解Flash ActionScript程序的运用逻辑与概念，让读者从实例中学习进而融会贯通。同时，本书也说明面向对象程序设计(00P)的语法及常用类别实例，提升读者制作F1ash作品的造诣和能力。全书共分为10章，精彩实例包括以三角函数制作的抽奖轮盘，FlashLite手机版孔明棋游戏，BitmapData类制作的数码相簿，使用Key对象移动狗狗，用绘图指令构成互动界面，虚拟实境对象与动态滤镜效果，英语测验影片等。　　附书光盘内容为书中实例源文件及完成作品。　　本书适用于有一定FIa sh使用基础的读者。","price":"45.00元"},{"rating":{"max":10,"numRaters":5,"average":"0.0","min":0},"subtitle":"","author":["邓劲生","Herbert Schildt","James holmes"],"pubdate":"2004-9-1","tags":[{"count":4,"name":"Java","title":"Java"},{"count":2,"name":"编程语言","title":"编程语言"},{"count":1,"name":"Java编程艺术","title":"Java编程艺术"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s1163820.jpg","binding":"平装(无盘)","translator":["邓劲生"],"catalog":"第1章 JAVA精髓\n第2章 递归下降的表达式解析器\n第3章 使用JAVA实现语言解释器\n第4章 使用JAVA创建下载管理器\n第5章 用JAVA实现E-mail客户端\n第6章 使用JAVA搜索Internet\n第7章 使用JAVA提交HTML\n第8章 统计、图表与JAVA\n第9章 金融应用中的Applet和Servlet\n第10章 基于AI的问题求解","pages":"356","images":{"small":"https://img3.doubanio.com\/spic\/s1163820.jpg","large":"https://img3.doubanio.com\/lpic\/s1163820.jpg","medium":"https://img3.doubanio.com\/mpic\/s1163820.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1187384\/","id":"1187384","publisher":"清华大学出版社","isbn10":"7302090548","isbn13":"9787302090540","title":"Java编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/1187384","alt_title":"","author_intro":"","summary":"本书揭示了Java程序员如何创建高质量软件的奥秘。Herbert Schildt 和James Holmes两位编程大师通过将Java应用于某些有趣、实用的计算机问题和编程任务中，全面展示了Java语言的强大功能、敏捷性、多样性和艺术性。本书各章内容分别涉及到Java精髓、递归下降的表达式解析器、用Java实现语言解释器、用Java创建下载管理器、用Java实现E-mail客户端和Internet搜索、用Java修饰HTML、显示统计图表、金融应用中的Applet和Servlet、基于AI的问题求解等，每章给出的示例代码都可以直接运行，无需修改，而且读者可以从www.osborne.com站点上免费下载这些代码。本书是亚马逊网站上的五星级图书，相信读者能够通过研读本书大大提高自己的Java开发能力。本书代码示例易懂有趣，设计思想独特，定会使您受益匪浅！","price":"45.0"},{"rating":{"max":10,"numRaters":6,"average":"0.0","min":0},"subtitle":"","author":["[美] Adam Machanic","Hugo Kornelis","Lara Rubbelke"],"pubdate":"2008-7","tags":[{"count":2,"name":"软件","title":"软件"},{"count":1,"name":"编程艺术","title":"编程艺术"},{"count":1,"name":"T-SQL","title":"T-SQL"},{"count":1,"name":"SQL_Server_2005","title":"SQL_Server_2005"},{"count":1,"name":"IT","title":"IT"},{"count":1,"name":"C\/C++","title":"C\/C++"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s5906156.jpg","binding":"","translator":["顔炯","薄建禄"],"catalog":"第1章　数据库领域的软件开发方法学\n1.1　架构回顾\n1.1.1　耦合、内聚和封装\n1.1.2　接口\n1.2　核心问题：集成数据库和面向对象系统\n1.2.1　该何去何从\n1.2.2　对象—关系失配\n1.3　ORM：一个问题多多的解决方案\n1.4　把数据库操作设计为API\n1.5　全面权衡\n1.5.1　可测试性\n1.5.2　可维护性\n1.5.3　安全性\n1.5.4　性能\n1.5.5　步履蹒跚的远期功能\n1.6　小结\n第2章　数据库例程测试\n2.1　黑盒测试与白盒测试简介\n2.1.1　单元测试和功能测试\n2.1.2　单元测试框架\n2.1.3　回归测试的重要性\n2.2　实现数据库测试过程和测试例程的指导准则\n2.2.1　为什么说软件测试很重要\n2.2.2　哪种测试重要\n2.2.3　需要进行多少测试\n2.2.4　管理层是否愿意接受软件测试\n2.3　性能测试和数据库系统事件探查\n2.3.1　获取基准度量\n2.3.2　使用跟踪器及事件探查器进行查看\n2.3.3　评估性能计数器\n2.3.4　宏观分析\n2.3.5　粒度分析\n2.3.6　修正问题：仅仅关注明显的错误是否已经足够\n2.4　SQLQueryStress性能测试工具介绍\n2.5　小结\n第3章　错误和异常\n3.1　异常和错误\n3.2　SQL Server中异常的工作原理\n3.2.1　语句级异常\n3.2.2　批处理程序级异常\n3.2.3　语法分析和作用域解析异常\n3.2.4　连接和服务器级异常\n3.2.5　XACT_ABORT设置\n3.2.6　分析错误信息\n3.2.7　SQL Server的RAISERROE函数\n3.2.8　跟踪监控异常事件\n3.3　异常处理\n3.3.1 为什么要在T-SQL中处理异常\n3.3.2 使用@@ERROR“处理”异常\n3.3.3 SQL Server的TRY\/CATCH语法\n3.4　事务与异常\n3.4.1　事务退出的神话\n3.4.2　XACT_ABORT：神话（半）成真\n3.4.3　TRY\/CATCH和被诅咒事务\n3.5　小结\n第4章　特权与授权\n4.1　最低特权原则\n4.1.1　在SQL Server中创建代理\n4.1.2　层级数据安全：洋葱模型\n4.2　使用Schema组织数据\n4.3　使用EXECUTE AS实现基本模拟\n4.4　所有权链\n4.5　非链式特权提升\n4.5.1　存储过程与EXECUTE AS\n4.5.2　使用证书对存储过程进行签名\n4.6　小结\n第5章　加密\n5.1　要保护什么\n5.2　加密术语：我们需要知道的部分\n5.3　SQL Server 2005加密密钥体系\n5.3.1　服务主密钥\n5.3.2　数据库主密钥\n5.4　SQL Server 2005数据保护\n5.4.1　HashBytes（）\n5.4.2　非对称密钥加密和证书加密\n5.4.3 对称密钥加密\n5.4.4　EncryptByPassphrase\n5.5　隔离数据与DBA\n5.6　性能优化设计\n5.6.1　设计解决方案、定义问题\n5.6.2　搜索加密数据\n5.7　小结\n第6章　SQLCLR：架构和设计注意事项\n6.1　填充SQL\/CLR鸿沟：SqlTypes库\n6.2　包装代码以提高跨层重用性\n6.3　SQLCLR的安全性特征和可靠性特征\n6.3.1　代码安全性需求\n6.3.2　通过程序集引用有选择地提升特权\n6.3.3　授予交叉程序集特权\n6.4　利用SQLCLR加强Service Broker可扩展性功能\n6.5　扩展用户自定义聚合\n6.6　小结\n第7章　动态T-SQL\n7.1 动态T-SQL与ad hoc T-SQL\n7.2 为什么要使用动态SQL\n7.2.1 编译与参数化\n7.2.2 自动参数化\n7.2.3 应用程序级参数化\n7.2.4 参数化与高速缓存的性能暗示\n7.3 支持可选参数\n7.3.1 通过静态T-SQL实现可选参数\n7.3.2 实现动态化：使用EXECUTE\n7.3.3 SQL注入\n7.3.4 sp_executesql：一个更好的EXECUTE\n7.4 动态SQL在安全方面的考虑\n7.4.1 被引用对象的权限\n7.4.2 接口规则\n7.5 小结\n第8章　应用程序并发系统的设计\n8.1 从业务角度观察：进程产生冲突时会发生什么情况\n8.1.1 SQL Server隔离级别概述\n8.1.2 并发控制与SQL Server提供的隔离级别\n8.2 做最坏的打算：悲观的并发\n8.2.1 在写入过程中使用悲观锁\n8.2.2 应用程序锁：对悲观并发控制机制进行泛化\n8.3 希望最好的情况发生：乐观的并发控制\n8.4 包容冲突：多值并发控制\n8.5 通过排队提高可扩展性\n8.6 小结\n第9章　空间数据处理\n9.1 用纬度和经度表示地球空间数据\n9.1.1 设置示例数据\n9.1.2 计算两点之间的距离\n9.1.3 从一个位置点移动到另一个位置点\n9.1.4 邻近搜索\n9.1.5 边界框\n9.1.6 查找距离最近的邻近点\n9.1.7 动态边界框\n9.1.8 结论\n9.2 使用分层三角形网格表示地球空间数据\n9.2.1 HTM的简化描述\n9.2.2 实现HtmID\n9.2.3 Spatial数据库提供的函数\n9.2.4 结论\n9.3 其他类型的空间数据\n9.3.1 三维数据\n9.3.2 天文数据\n9.3.3 虚拟空间\n9.3.4 将区域表达为多边形\n9.4 小结\n第10章　时态数据处理\n10.1 表达的不仅仅是时间\n10.2 SQL Server提供的日期\/时间数据类型\n10.2.1 日期输入格式\n10.2.2　格式化输出日期\n10.2.3 高效查询日期\/时间列\n10.2.4 日期\/时间计算\n10.3 使用日历表定义周期\n10.4 设计时态数据存储方案及查询时态数据\n10.4.1 处理时区\n10.4.2 处理时间区间\n10.4.3 为持续时间建立模型\n10.4.4 管理双时态数据\n10.5 小结\n第11章　树、层次结构和图\n11.1 术语：万物皆为图\n11.2 基础知识：邻接表和图\n11.2.1 为边加入约束\n11.2.2 针对图的基本查询：给定一个结点，这个结点与其他哪些结点相连\n11.2.3 遍历图\n11.3 邻接表的层次结构\n11.3.1 查询邻接表层次结构：基础知识\n11.3.2 查找直接后代结点\n11.3.3 在层次结构中向下级层次遍历\n11.3.4 在层次结构中向上级层次遍历\n11.3.5 插入新结点并重新定位子树\n11.3.6 删除已有结点\n11.3.7 为层次结构加入约束\n11.4 持久保存具体化路径\n11.4.1 查找下级结点\n11.4.2 在层次结构中向上级层次导航\n11.4.3 对具体化路径解决方案进行优化\n11.4.4 插入结点\n11.4.5 重新定位子树\n11.4.6 删除结点\n11.4.7 为层次结构加入约束\n11.5 嵌套集模型\n11.5.1 查找下级结点\n11.5.2 在层次结构中向上级层次导航\n11.5.3 插入结点\n11.5.4 重新定位子树\n11.5.5 删除结点\n11.5.6 为层次结构加入约束\n11.6 小结","pages":"379","images":{"small":"https://img3.doubanio.com\/spic\/s5906156.jpg","large":"https://img3.doubanio.com\/lpic\/s5906156.jpg","medium":"https://img3.doubanio.com\/mpic\/s5906156.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3105777\/","id":"3105777","publisher":"人民邮电出版社","isbn10":"7115179352","isbn13":"9787115179357","title":"SQL Server 2005编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/3105777","alt_title":"","author_intro":"Adam Machanic，微软SQL Server MVP，著名的SQL Server专家。长期活跃于技术社区，是SQL Server Professional和TechNET等行业杂志的撰稿人，经常在各种技术会议上开设技术讲座、发表演讲。除本书外，他还是Pro SQL Server 2005的作者之一。","summary":"《SQL Server 2005编程艺术》是一部关于SQL Server 2005 高级开发技术的权威著作，提供了详尽、全面的技术讨论，并给出了详细的应用实例。书中前4 章着重介绍SQL Server 所涉及的软件开发方法学、测试、异常处理和安全；第5 章至第7 章深入研究SQL Server 独具的高级特性，主要介绍加密、SQLCLR 和动态SQL；第8 章至第11 章从数据库体系结构的角度分析问题，深入研究具体的设计和实现问题，包括应用程序并发、空间数据、时态数据和图，这是《SQL Server 2005编程艺术》最为复杂的内容，也是最有实际意义的内容。","series":{"id":"28522","title":"图灵程序设计丛书·数据库系列"},"price":"59.00元"},{"rating":{"max":10,"numRaters":1,"average":"0.0","min":0},"subtitle":"","author":["蔡明志"],"pubdate":"2013-1","tags":[{"count":4,"name":"指针","title":"指针"},{"count":2,"name":"c语言","title":"c语言"},{"count":2,"name":"C","title":"C"},{"count":1,"name":"计算机科学","title":"计算机科学"},{"count":1,"name":"1","title":"1"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s24558417.jpg","binding":"","translator":[],"catalog":"","pages":"432","images":{"small":"https://img1.doubanio.com\/spic\/s24558417.jpg","large":"https://img1.doubanio.com\/lpic\/s24558417.jpg","medium":"https://img1.doubanio.com\/mpic\/s24558417.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20424479\/","id":"20424479","publisher":"","isbn10":"7115294267","isbn13":"9787115294265","title":"指针的编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/20424479","alt_title":"","author_intro":"","summary":"《指针的编程艺术(第二版)》内容精彩无比，除了对C语言的指针有深入的探讨外，同时也对与指针有异曲同工之妙的reference详加讨论。《指针的编程艺术(第二版)》以指针为核心，讲解了指针与变量、指针与数组、指针与函数、指针与字符串、指针与结构、链表、指针与文件等编程技术，可以帮助读者快速进入指针的世界，是一本难得的指导书。\n　　《指针的编程艺术(第二版)》适合程序员阅读，也适合作为大中专院校的学习用书以及培训学校的教材。","price":"65.00元"},{"rating":{"max":10,"numRaters":2,"average":"0.0","min":0},"subtitle":"","author":["魏家明"],"pubdate":"2014-1","tags":[{"count":2,"name":"HDl","title":"HDl"},{"count":1,"name":"自我修炼","title":"自我修炼"},{"count":1,"name":"技术","title":"技术"},{"count":1,"name":"verilog","title":"verilog"},{"count":1,"name":"IC","title":"IC"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s28296724.jpg","binding":"平装","translator":[],"catalog":"目    录\n第一部分  设 计 原 则\n第1章  美的设计\t2\n1.1  美学观点\t2\n1.2  美是修养\t3\n1.3  专业术语\t4\n第2章  高效之道\t5\n2.1  敏捷开发\t5\n2.2  代码质量\t6\n2.3  版本控制\t7\n2.4  提早集成\t7\n第3章  组织管理\t9\n3.1  植物分类\t9\n3.2  SoC特性\t11\n3.3  设计流程\t12\n3.4  仔细规划\t12\n3.5  管理表格\t13\n3.6  模块层次\t14\n3.7  目录组织\t14\n第4章  使用工具\t19\n4.1  使用Emacs\t19\n4.1.1  Emacs介绍\t19\n4.1.2  Emacs安装\t19\n4.1.3  常用快捷键\t20\n4.1.4  我的.emacs\t21\n4.1.5  cua-base.el\t22\n4.1.6  verilog-mode.el\t23\n4.1.7  shell buffer\t23\n4.2  使用Shell\t24\n4.2.1  Shell介绍\t24\n4.2.2  Shell例子\t24\n4.2.3  Perl例子\t25\n4.3  使用CVS\t26\n4.3.1  CVS介绍\t26\n4.3.2  CVS术语\t27\n4.3.3  CVS初始化\t27\n4.3.4  CVS常用命令\t29\n第5章  编码风格\t31\n5.1  干干净净\t32\n5.2  代码划分\t32\n5.3  代码要求\t33\n5.3.1  Verilog部分\t33\n5.3.2  SystemVerilog部分\t40\n5.4  名字定义\t40\n5.5  书写格式\t42\n5.5.1  模块端口声名\t42\n5.5.2  模块实例化\t45\n5.5.3  函数和任务调用\t47\n5.5.4  书写语句\t47\n5.5.5  书写表达式\t48\n5.6  添加注释\t49\n5.7  参数化\t50\n5.8  lint检查\t52\n第二部分  语 言 特 性\n第6章  Verilog特性\t54\n6.1  Verilog标准\t54\n6.2  抽象级别\t54\n6.3  可综合子集\t55\n6.4  保持一致\t57\n第7章  常数\t58\n7.1  整数（integer）\t58\n7.2  实数（real）\t60\n7.3  字符串（string）\t60\n7.4  标识符（identifier）\t60\n第8章  数据类型\t61\n8.1  线网（net）\t61\n8.1.1  wire和tri\t61\n8.1.2  wor、wand、trior、triand\t61\n8.1.3  tri0、tri1\t61\n8.1.4  uwire\t61\n8.1.5  supply0、supply1\t62\n8.1.6  驱动强度\t62\n8.1.7  默认net\t62\n8.2  变量（variable）\t62\n8.3  线网和变量的区别\t63\n8.4  向量（vector）\t64\n8.5  数组（array）\t65\n8.6  多维数组\t65\n第9章  表达式\t67\n9.1  操作符（Operator）\t67\n9.1.1  操作符的优先级（Operator priority）\t68\n9.1.2  表达式中使用整数\t68\n9.1.3  算数操作符（Arithmetic operators）\t69\n9.1.4  算术表达式中的regs和integers\t69\n9.1.5  比较操作符（Compare operators）\t70\n9.1.6  逻辑操作符（Logical operators）\t70\n9.1.7  位运算操作符（Bitwise operators）\t71\n9.1.8  归约操作符（Reduction operators）\t71\n9.1.9  移位操作符（Shift operators）\t71\n9.1.10  条件操作符（Conditional operator）\t72\n9.1.11  连接操作符（Concatenations）\t72\n9.2  操作数（Operands）\t73\n9.2.1  向量的抽取（bit-select and part-select）\t73\n9.2.2  part-select的例子\t75\n9.2.3  数组的访问\t75\n9.2.4  字符串\t76\n9.3  表达式位长（Expression bit lengths）\t77\n9.3.1  表达式位长规则\t77\n9.3.2  表达式位长问题的例子A\t78\n9.3.3  表达式位长问题的例子B\t79\n9.3.4  表达式位长问题的例子C\t79\n9.3.5  表达式位长问题的例子D\t79\n9.3.6  表达式位长问题的例子E\t80\n9.4  符号表达式（Signed expressions）\t80\n9.4.1  表达式类型规则\t81\n9.4.2  计算表达式的步骤\t81\n9.4.3  执行赋值的步骤\t82\n9.4.4  signed表达式中处理x和z\t82\n9.4.5  signed应用的例子\t82\n9.4.6  signed应用的错误\t83\n9.5  赋值和截断（Assignments and truncation）\t84\n9.6  与x\/z比较\t85\n第10章  赋值操作\t86\n10.1  连续赋值\t86\n10.2  过程赋值\t87\n第11章  门级和开关级模型\t88\n11.1  门和开关的声明语法\t88\n11.1.1  门和开关类型\t88\n11.1.2  驱动强度\t88\n11.1.3  延迟\t89\n11.1.4  实例数组\t89\n11.2  and、nand、nor、or、xor、xnor\t90\n11.3  buf、not\t90\n11.4  bufif1、bufif0、notif1、notif0\t90\n11.5  MOS switches\t90\n11.6  Bidirectional pass switches\t91\n11.7  pullup、pulldown\t91\n第12章  用户定义原语\t92\n12.1  UDP定义\t92\n12.1.1  UDP状态表\t92\n12.1.2  状态表符号\t93\n12.2  组合UDP\t93\n12.3  电平敏感时序UDP\t93\n12.4  沿敏感时序UDP\t94\n第13章  行为模型\t97\n13.1  概览\t97\n13.2  过程赋值\t98\n13.2.1  阻塞赋值\t98\n13.2.2  非阻塞赋值\t99\n13.3  过程连续赋值\t102\n13.3.1  assign和deassign过程语句\t103\n13.3.2  force和release过程语句\t103\n13.4  条件语句\t104\n13.5  循环语句\t105\n13.5.1  for循环例子\t106\n13.5.2  disable语句\t107\n13.6  过程时序控制\t108\n13.6.1  延迟控制（Delay control）\t108\n13.6.2  事件控制（Event control）\t108\n13.6.3  命名事件（Named events）\t109\n13.6.4  事件or操作符（Event or operator）\t109\n13.6.5  隐含事件列表（Implicit event_expression list）\t109\n13.6.6  电平敏感事件控制（Level-sensitive event control）\t111\n13.6.7  赋值间时序控制（Intra-assignment timing controls）\t111\n13.7  块语句\t113\n13.7.1  顺序块（Sequential block）\t113\n13.7.2  并行块（Parallel block）\t114\n13.7.3  块名字（Block names）\t114\n13.7.4  开始和结束时间（Start and finish times）\t114\n13.8  结构化过程\t116\n13.8.1  initial construct\t116\n13.8.2  always construct\t116\n13.8.3  always的敏感列表\t117\n13.8.4  并发进程\t117\n13.9  always有关的问题\t118\n13.9.1  敏感列表不完整\t118\n13.9.2  赋值顺序错误\t119\n第14章  case语句\t120\n14.1  case语句定义\t121\n14.2  case语句的执行\t122\n14.3  Verilog和VHDL对比\t123\n14.4  case的应用\t123\n14.5  casez的应用\t125\n14.6  描述状态机\t126\n14.7  casex的误用\t127\n14.8  casez的误用\t128\n14.9  full_case 和parallel_case\t128\n14.10  full_case\t129\n14.10.1  不是full的case语句\t129\n14.10.2  是full的case语句\t129\n14.10.3  使用full_case综合指令\t130\n14.10.4  full_case综合指令的缺点\t131\n14.10.5  使用full_case指令后还是生成Latch\t132\n14.11  parallel_case\t132\n14.11.1  不是parallel的case语句\t132\n14.11.2  是parallel的case语句\t133\n14.11.3  使用parallel_case综合指令\t133\n14.11.4  parallel_case综合指令的缺点\t134\n14.11.5  没有必要的parallel_case指令\t135\n14.12  综合时的警告\t135\n14.13  case语句的编码原则\t136\n第15章  task和function\t137\n15.1  task和function之间的不同点\t137\n15.2  task的声明和使能\t137\n15.2.1  task的声明\t137\n15.2.2  task的使能和参数传递\t138\n15.2.3  task的内存使用和并发进程\t140\n15.3  disable语句\t141\n15.3.1  disable语句的例子A\t141\n15.3.2  disable语句的例子B\t143\n15.4  function的声明和调用\t145\n15.4.1  function的声明\t145\n15.4.2  function的返回值\t147\n15.4.3  function的调用\t147\n15.4.4  function的规则\t147\n15.4.5  constant function\t148\n15.5  task的误用\t149\n15.6  function的误用\t149\n第16章  调度和赋值\t151\n16.1  仿真过程\t151\n16.2  事件仿真\t151\n16.3  仿真参考模型\t152\n16.4  分层事件队列\t153\n16.4.1  事件队列分类\t154\n16.4.2  事件队列特性\t155\n16.4.3  事件调度例子\t155\n16.5  确定性和不确定性\t157\n16.5.1  确定性（Determinism）\t157\n16.5.2  不确定性（Nondeterminism）\t157\n16.6  赋值的调度含义\t158\n16.6.1  连续赋值\t159\n16.6.2  过程连续赋值\t159\n16.6.3  阻塞赋值\t159\n16.6.4  非阻塞赋值\t159\n16.6.5  开关处理\t159\n16.6.6  端口连接\t159\n16.6.7  任务和函数\t160\n16.7  阻塞赋值和非阻塞赋值\t160\n16.7.1  阻塞赋值\t160\n16.7.2  非阻塞赋值\t161\n16.8  赋值使用原则\t161\n16.9  自己触发自己\t162\n16.10  仿真零延迟RTL模型\t163\n16.11  惯性延迟和传输延迟\t165\n16.11.1  门级仿真中的传输延迟\t166\n16.11.2  各种#delay的位置\t168\n16.11.3  仿真时钟生成方法\t169\n16.12  延迟线模型\t170\n16.13  使用#1延迟\t171\n16.14  多个公共时钟和竞争条件\t172\n16.15  避免混杂阻塞赋值和非阻塞赋值\t173\n16.16  RTL和门级混合仿真\t176\n16.16.1  RTL-to-Gates仿真\t177\n16.16.2  Gates-to-RTL仿真\t177\n16.16.3  有时钟偏差的门级时钟树\t178\n16.16.4  有时钟偏差的Vendor模型\t178\n16.16.5  错误的Vendor模型\t179\n16.16.6  结论和建议\t183\n16.17  带有SDF延迟的门级仿真\t183\n16.17.1  全系统仿真\t183\n16.17.2  软件要花钱\t184\n16.17.3  门级回归仿真\t184\n16.18  验证平台技巧\t185\n16.18.1  在0时刻复位\t186\n16.18.2  时钟沿之后复位\t186\n16.18.3  创建仿真时钟\t186\n16.18.4  在无效沿输入激励\t187\n第17章  层次结构\t188\n17.1  模块\t188\n17.1.1  模块定义\t188\n17.1.2  模块实例\t188\n17.2  参数\t188\n17.2.1  参数声明\t189\n17.2.2  参数调整\t189\n17.2.3  参数传递\t190\n17.2.4  参数依赖\t192\n17.2.5  内部参数\t193\n17.2.6  clog2\t193\n17.2.7  指数**\t194\n17.3  端口\t194\n17.3.1  端口声明\t194\n17.3.2  端口连接\t195\n17.3.3  实数传递\t196\n17.4  Generate语句\t196\n17.4.1  Loop generate construct\t197\n17.4.2  Conditional generate construct\t200\n17.5  实例数组\t201\n17.6  层次名字\t203\n第18章  系统任务和函数\t205\n18.1  显示任务\t205\n18.1.1  显示和写出任务\t205\n18.1.2  探测任务\t208\n18.1.3  监控任务\t209\n18.2  文件读写\t209\n18.2.1  打开和关闭文件\t209\n18.2.2  文件输出\t211\n18.2.3  字符串输出\t212\n18.2.4  文件输入\t213\n18.2.5  文件定位\t216\n18.2.6  刷新输出\t216\n18.2.7  错误状态\t216\n18.2.8  检查文件尾部\t217\n18.2.9  加载文件数据\t217\n18.3  时间比例\t218\n18.3.1  $printtimescale\t218\n18.3.2  $timeformat\t218\n18.4  仿真控制\t218\n18.4.1  $finish\t218\n18.4.2  $stop\t218\n18.5  仿真时间\t218\n18.6  转换函数\t219\n18.7  概率分布\t220\n18.7.1  $random\t220\n18.7.2  $dist_functions\t220\n18.8  命令行输入\t220\n18.8.1  $test$plusargs\t221\n18.8.2  $value$plusargs\t221\n18.9  数学运算\t223\n18.9.1  整数函数\t223\n18.9.2  实数函数\t223\n18.10  波形记录\t224\n第19章  编译指令\t225\n19.1  `celldefine和`endcelldefine\t225\n19.2  `default_nettype\t225\n19.3  `define和`undef\t226\n19.4  `ifdef、`else、`elsif、`endif、`ifndef\t227\n19.5  `include\t228\n19.6  `resetall\t228\n19.7  `line\t228\n19.8  `timescale\t229\n19.9  `unconnected_drive和`nounconnected_drive\t230\n19.10  `begin_keywords和`end_keywords\t230\n19.11  `pragma\t230\n第20章  Specify块\t231\n20.1  specify块声明\t231\n20.2  speparam\t231\n20.3  模块路径声明\t232\n20.3.1  模块路径要求\t232\n20.3.2  简单路径\t232\n20.3.3  沿敏感路径\t233\n20.3.4  状态依赖路径\t234\n20.4  模块路径延迟\t235\n第21章  时序检查\t237\n21.1  概览\t237\n21.2  使用稳定窗口的时序检查\t237\n21.2.1  $setup、$hold、$setuphold\t238\n21.2.2  $recovery、$removal、$recrem\t238\n21.3  时钟和控制信号的时序检查\t240\n21.3.1  $skew、$timeskew、$fullskew\t240\n21.3.2  $width\t240\n21.3.3  $period\t241\n21.3.4  $nochange\t241\n21.4  使用notifier响应时序违反\t241\n21.5  使用条件事件\t242\n21.6  时序检查中的Vector\t243\n21.7  Negative timing check\t243\n第22章  反标SDF\t246\n22.1  SDF标注器\t246\n22.2  SDF construct到Verilog的映射\t246\n22.2.1  SDF路径延迟到Verilog的映射\t246\n22.2.2  SDF时序检查到Verilog的映射\t247\n22.2.3  SDF互连延迟的标注\t248\n22.3  $sdf_annotate\t249\n22.4  SDF文件例子\t250\n第23章  编程语言接口\t252\n23.1  DirectC\t252\n23.2  SystemVerilog\t252\n第24章  综合指令\t253\n24.1  Synopsys综合指令\t253\n24.2  使用综合指令\t253\n24.3  使用translate_off\/on\t254\n24.4  误用translate_off\/on\t256\n24.5  使用attribute\t256\n第三部分  书 写 文 档\n第25章  书写文档\t260\n25.1  文档格式\t260\n25.2  定义文档\t261\n25.3  应用文档\t262\n25.4  设计文档\t262\n25.5  备份文档\t263\n25.6  GPIO设计\t263\n第26章  GPIO应用文档\t264\n26.1  Overview\t264\n26.2  Register Description\t264\n26.2.1  PIN Level Register (PIN)\t265\n26.2.2  Data Register (DAT)\t265\n26.2.3  Data Set Register (DATS)\t265\n26.2.4  Data Clear Register (DATC)\t265\n26.2.5  Mask Register (IM)\t266\n26.2.6  Mask Set Register (IMS)\t266\n26.2.7  Mask Clear Register (IMC)\t266\n26.2.8  PULL Enable Register (PEN)\t266\n26.2.9  PEN Enable Set Register Register (PENS)\t266\n26.2.10  PEN Enable Clear Register Register (PENC)\t266\n26.2.11  PSEL Select Register (PSEL)\t266\n26.2.12  PSEL Enable Set Register Register (PSELS)\t266\n26.2.13  PSEL Enable Clear Register Register (PSELC)\t267\n26.2.14  Function Register (FUN)\t267\n26.2.15  Function Set Register (FUNS)\t267\n26.2.16  Function Clear Register (FUNC)\t267\n26.2.17  Select Register (SEL)\t267\n26.2.18  Select Set Register (SELS)\t267\n26.2.19  Select Clear Register (SELC)\t267\n26.2.20  Direction Register (DIR)\t267\n26.2.21  Direction Set Register (DIRS)\t268\n26.2.22  Direction Clear Register (DIRC)\t268\n26.2.23  Trigger Register (TRG)\t268\n26.2.24  Trigger Set Register (TRGS)\t268\n26.2.25  Trigger Clear Register (TRGC)\t268\n26.2.26  FLAG Register (FLG)\t268\n26.2.27  FLAG Clear Register (FLGC)\t269\n26.3  Program Guide\t269\n26.3.1  GPIO Function Guide\t269\n26.3.2  Alternate Function Guide\t269\n26.3.3  Interrupt Function Guide\t269\n26.3.4  Disable Interrupt Function Guide\t270\n第27章  GPIO设计文档\t271\n27.1  文件列表（见表27-1）\t271\n27.2  端口列表（见表27-2）\t271\n27.3  配置参数（见表27-3）\t272\n第四部分  高 级 设 计\n第28章  使用IP\t274\n28.1  Cadence的IP\t274\n28.2  Cadence的VIP\t275\n28.3  Synopsys的IP\t275\n28.4  DesignWare Building Block\t276\n28.5  在FPGA上使用DesignWare\t276\n第29章  代码优化\t278\n29.1  代码可读\t278\n29.2  简洁编码\t279\n29.3  优化逻辑\t281\n29.4  优化迟到信号\t281\n29.5  括号控制结构\t282\n第30章  状态机设计\t283\n30.1  状态机类型\t283\n30.2  状态编码方式\t283\n30.3  二进制编码FSM\t284\n30.3.1  两个always块\t284\n30.3.2  重要的编码规则\t285\n30.3.3  错误状态的转换\t285\n30.3.4  next的默认值\t285\n30.4  独热码编码FSM\t286\n30.5  寄存器输出\t287\n第31章  可配置设计\t289\n31.1  格雷码转换\t289\n31.2  通用串行CRC\t290\n31.2.1  general_crc.v\t290\n31.2.2  testbench\t292\n31.3  FIFO控制器\t293\n31.4  RAM Wrapper 例子\t296\n31.4.1  常规方法\t296\n31.4.2  名字规范化\t297\n31.4.3  RF1_wrapper.v\t298\n31.4.4  gen_wrapper.pl\t302\n31.4.5  ram_def.txt例子\t306\n31.4.6  生成wrapper\t307\n31.5  可配置的GPIO设计\t308\n31.5.1  gpio.v\t308\n31.5.2  gpio_params.v\t317\n31.5.3  gpio_check.v\t317\n31.5.4  gpio_reg.v\t318\n31.5.5  gpio_sync.v\t319\n31.6  可配置的BusMatrix\t320\n31.6.1  BusMatrix简介\t320\n31.6.2  设计ABM\t321\n31.6.3  mini_abm\t322\n31.6.4  large_abm\t331\n31.7  可配置的Andes Core N801\t333\n31.8  可配置的ARM926EJS\t334\n31.9  灵活的coreConsultant\t336\n第32章  可测性设计\t337\n32.1  内部扫描\t337\n32.2  内建自测\t339\n32.3  边界扫描\t340\n第五部分  时钟和复位\n第33章  异步时序\t342\n33.1  亚稳态\t342\n33.2  MTBF\t343\n33.3  同步器\t344\n33.3.1  电平同步器\t344\n33.3.2  边沿检测同步器\t345\n33.3.3  脉冲检测同步器\t345\n33.4  同步多位数据\t347\n33.5  异步FIFO\t348\n33.6  Design Ware\t348\n33.7  DW_fifoctl_s2_sf\t349\n33.8  门级仿真\t351\n第34章  时钟生成\t352\n34.1  同步电路\t352\n34.2  设计原则\t353\n34.3  分频器\t353\n34.3.1  1\/n分频器\t353\n34.3.2  n\/d分频器\t355\n34.4  时钟切换\t355\n34.5  时钟生成\t358\n第35章  时钟例子\t362\n35.1  Overview\t362\n35.2  CGU Clock\t362\n35.2.1  Clock List\t362\n35.2.2  Clock Diagram（见图35-1）\t363\n35.2.3  Clock Divider Rate（见表35-1）\t364\n35.3  Register Description（见表35-2）\t364\n35.3.1  CGU PLL Divider Register (CGU_PDR)\t364\n35.3.2  CGU Counter Regsister (CGU_CNT)\t365\n35.3.3  CGU PLL Control Register (CGU_PCR)\t365\n35.3.4  CGU Low Power Control Register (CGU_LPC)\t365\n35.3.5  CGU Status Register (CGU_CST)\t365\n35.3.6  CGU Divider 0 Register (CGU_DV0→1\/s)\t366\n35.3.7  CGU Divider 1 Register (CGU_DV1→1\/x)\t366\n35.3.8  CGU Divider 2 Register (CGU_DV2→1\/n)\t366\n35.3.9  CGU Divider 3 Register (CGU_DV3→1\/n)\t367\n35.3.10  CGU Divider 4\/5\/6\/7 Register (CGU_DV4\/5\/6\/7→n\/d)\t367\n35.3.11  CGU Divider 8 Register (CGU_DV8→n\/d)\t367\n35.3.12  CGU Divider 9 Register (CGU_DV9→n\/d)\t367\n35.3.13  CGU Module Stop 0 Register (CGU_MS0)\t367\n35.3.14  CGU Module Stop 1 Register (CGU_MS1)\t368\n35.3.15  CGU Module Stop 2 Register (CGU_MS2)\t368\n35.3.16  CGU Reset Control Register (CGU_RCR)\t369\n35.3.17  CGU Reset Status Register (CGU_RST)\t369\n35.4  PLL Structure\t369\n35.4.1  Frequency Calculation\t370\n35.4.2  VCO Frequency Limitation\t370\n35.4.3  PFD Clock Frequency Limitation\t370\n35.5  PLL Control\t371\n35.6  Sleep and Wakeup\t371\n35.6.1  State switch\t371\n35.6.2  How to wakeup\t372\n35.7  Module Stop\t372\n35.8  Application Notes\t373\n第36章  复位设计\t374\n36.1  复位的用途\t374\n36.2  寄存器编码风格\t374\n36.2.1  有\/无同步复位寄存器\t374\n36.2.2  寄存器推导原则\t376\n36.3  同步复位\t376\n36.3.1  编码风格和电路\t377\n36.3.2  同步复位的优点\t378\n36.3.3  同步复位的缺点\t379\n36.4  异步复位\t379\n36.4.1  编码风格和电路\t380\n36.4.2  既有异步复位又有异步置位的寄存器\t380\n36.4.3  异步复位的优点\t381\n36.4.4  异步复位的缺点\t382\n36.5  异步复位的问题\t382\n36.5.1  复位recovery时间\t383\n36.5.2  复位撤销经历不同的时钟周期\t383\n36.6  复位同步器\t383\n36.6.1  复位同步器有亚稳态吗？\t384\n36.6.2  错误的ASIC Vendor模型\t385\n36.6.3  有缺点的复位同步器\t385\n36.6.4  复位时的仿真验证\t386\n36.7  复位分布树\t387\n36.7.1  同步复位分布技巧\t389\n36.7.2  异步复位分布技巧\t389\n36.7.3  复位分布树的时序分析\t390\n36.8  复位毛刺的过滤\t391\n36.9  异步复位的DFT\t391\n36.10  多时钟复位的问题\t392\n36.10.1  非协调的复位撤销\t392\n36.10.2  顺序协调的复位撤销\t393\n36.11  结论\t394\n第六部分  验 证 之 路\n第37章  验证之路\t396\n37.1  整洁验证\t397\n37.2  验证目标\t398\n37.3  验证流程\t398\n37.4  验证计划\t398\n37.5  随机验证\t399\n37.6  直接验证\t399\n37.7  白盒验证\t399\n37.8  模块验证\t400\n37.9  系统验证\t400\n37.9.1  验证重点\t400\n37.9.2  验证环境\t401\n37.9.3  IP互连\t401\n37.9.4  性能验证\t401\n37.10  DFT验证\t402\n37.11  网表验证\t402\n37.12  高级抽象\t403\n37.13  灵活验证\t405\n37.14  ARM926EJS的Validation环境\t406\n37.14.1  Validation tools\t407\n37.14.2  Validation configuration files\t407\n37.14.3  Validation test suites\t407\n37.14.4  Validation flow\t408\n37.14.5  Building the model\t408\n37.14.6  Running Validation test suites\t408\n37.14.7  Debugging a single Validation test\t410\n37.15  AHB BusMatrix的验证\t411\n37.16  某芯片的SoC验证环境\t411\n第七部分  其 他 介 绍\n第38章  SystemVerilog特性\t414\n38.1  SystemVerilog与Systemc比较\t414\n38.2  SystemVerilog的特点\t414\n38.3  新的数据类型\t415\n38.3.1  整型和实型\t415\n38.3.2  新的操作符\t416\n38.3.3  数组\t416\n38.3.4  队列\t417\n38.3.5  枚举类型\t417\n38.3.6  结构体和共同体\t417\n38.4  always_comb、always_latch和always_ff\t417\n38.5  unique和priority\t418\n38.6  loop、break和continue\t419\n38.7  task和function\t419\n38.7.1  静态和自动作用域\t419\n38.7.2  参数传递\t420\n38.7.3  参数中的默认值\t420\n38.8  Port connection\t421\n38.9  Tag\t421\n38.10  Interface\t422\n38.11  class和object\t425\n38.11.1  对象的概念\t425\n38.11.2  类的创建\t426\n38.11.3  类的继承\t427\n38.11.4  类的randomize\t428\n38.11.5  类的cover group\t429\n38.12  VMM、OVM和UVM\t429\n参考文献\t431\n关于版权\t432","pages":"456","images":{"small":"https://img3.doubanio.com\/spic\/s28296724.jpg","large":"https://img3.doubanio.com\/lpic\/s28296724.jpg","medium":"https://img3.doubanio.com\/mpic\/s28296724.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26612391\/","id":"26612391","publisher":"电子工业出版社","isbn10":"712122061X","isbn13":"9787121220616","title":"Verilog编程艺术","url":"https:\/\/api.douban.com\/v2\/book\/26612391","alt_title":"","author_intro":"","summary":"本书深入地探讨了Verilog编程，分为七个部分：设计原则、语言特性、书写文档、高级设计、时钟和复位、验证之路、其他介绍。本书对这些部分做了重点的探讨：Verilog编码风格、Verilog-2001的新特性、简洁高效的编程、容易出错的语言元素、可配置设计、时钟生成、复位设计、验证方法等。另外，本书还对SystemVerilog做了简单的介绍。","price":"79.00元"}]}